// Generated Code - DO NOT EDIT !!
// generated by 'emugen'


#include <string.h>
#include "gles2_opcodes.h"

#include "gles2_dec.h"


#include "external\android-emugl\shared\OpenglCodecCommon\ProtocolUtils.h"

#include "external\android-emugl\shared\OpenglCodecCommon\ChecksumCalculatorThreadInfo.h"

#include <stdio.h>

typedef unsigned int tsize_t; // Target "size_t", which is 32-bit for now. It may or may not be the same as host's size_t when emugen is compiled.

#  define DEBUG(...) do { if (emugl_cxt_logger) { emugl_cxt_logger(LogLevel::TRACE, __VA_ARGS__); } } while(0)

#ifdef CHECK_GLERROR
#  define SET_LASTCALL(name)  sprintf(lastCall, #name)
#else
#  define SET_LASTCALL(name)  ((void)0)
#endif

using namespace emugl;

void gles2_decoder_context_t::freeShader(){
                       
	auto it = m_shaders.begin();
	m_lock.lock();
	while(it != m_shaders.end()) 
	{
		this->glDeleteShader(it->first);
		it++;
	}
	m_lock.unlock();
}

void gles2_decoder_context_t::freeProgram(){
		
	auto it = m_programs.begin(); 
	m_lock.lock();
	while(it != m_programs.end()) 
	{
		this->glDeleteProgram(it->first);
		it++;
	}
	m_lock.unlock();
}

size_t gles2_decoder_context_t::decode(void *buf, size_t len, IOStream *stream)
{
                           
	size_t pos = 0;
	if (len < 8) return pos; 
	unsigned char *ptr = (unsigned char *)buf;
	bool unknownOpcode = false;  
#ifdef CHECK_GL_ERROR 
	char lastCall[256] = {0}; 
#endif 
	while ((len - pos >= 8) && !unknownOpcode) {   
		uint32_t opcode = *(uint32_t *)ptr;   
		size_t packetLen = *(uint32_t *)(ptr + 4);
		if (len - pos < packetLen)  return pos; 
		bool useChecksum = ChecksumCalculatorThreadInfo::getVersion() > 0;
		size_t checksumSize = 0;
		if (useChecksum) {
			checksumSize = ChecksumCalculatorThreadInfo::checksumByteSize();
		}
		if (opcode < 10000) {
			printf("%d \n", opcode);
		}
		
		switch(opcode) {
		case OP_glActiveTexture: {
			GLenum var_texture = Unpack<GLenum,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"8 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glActiveTexture(0x%08x )", stream,var_texture);
			this->glActiveTexture(var_texture);
			SET_LASTCALL("glActiveTexture");
			break;
		}
		case OP_glAttachShader: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			GLuint var_shader = Unpack<GLuint,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize, 
					"8 + 4 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glAttachShader(%u %u )", stream,var_program, var_shader);
			this->glAttachShader(var_program, var_shader);
			SET_LASTCALL("glAttachShader");

						m_lock.lock();
			m_shaders.insert({var_shader, 1});
			m_lock.unlock();
			break;
		}
		case OP_glBindAttribLocation: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			GLuint var_index = Unpack<GLuint,uint32_t>(ptr + 8 + 4);
			uint32_t size_name  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			InputBuffer inptr_name(ptr + 8 + 4 + 4 + 4, size_name);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4 + size_name, ptr + 8 + 4 + 4 + 4 + size_name, checksumSize, 
					"8 + 4 + 4 + 4 + size_name::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glBindAttribLocation(%u %u %p(%u) )", stream,var_program, var_index, (const GLchar*)(inptr_name.get()), size_name);
			this->glBindAttribLocation(var_program, var_index, (const GLchar*)(inptr_name.get()));
			SET_LASTCALL("glBindAttribLocation");
			break;
		}
		case OP_glBindBuffer: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLuint var_buffer = Unpack<GLuint,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize, 
					"8 + 4 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glBindBuffer(0x%08x %u )", stream,var_target, var_buffer);
			this->glBindBuffer(var_target, var_buffer);
			SET_LASTCALL("glBindBuffer");
			break;
		}
		case OP_glBindFramebuffer: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLuint var_framebuffer = Unpack<GLuint,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize, 
					"8 + 4 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glBindFramebuffer(0x%08x %u )", stream,var_target, var_framebuffer);
			this->glBindFramebuffer(var_target, var_framebuffer);
			SET_LASTCALL("glBindFramebuffer");
			break;
		}
		case OP_glBindRenderbuffer: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLuint var_renderbuffer = Unpack<GLuint,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize, 
					"8 + 4 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glBindRenderbuffer(0x%08x %u )", stream,var_target, var_renderbuffer);
			this->glBindRenderbuffer(var_target, var_renderbuffer);
			SET_LASTCALL("glBindRenderbuffer");
			break;
		}
		case OP_glBindTexture: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLuint var_texture = Unpack<GLuint,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize, 
					"8 + 4 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glBindTexture(0x%08x %u )", stream,var_target, var_texture);
			this->glBindTexture(var_target, var_texture);
			SET_LASTCALL("glBindTexture");
			break;
		}
		case OP_glBlendColor: {
			GLclampf var_red = Unpack<GLclampf,uint32_t>(ptr + 8);
			GLclampf var_green = Unpack<GLclampf,uint32_t>(ptr + 8 + 4);
			GLclampf var_blue = Unpack<GLclampf,uint32_t>(ptr + 8 + 4 + 4);
			GLclampf var_alpha = Unpack<GLclampf,uint32_t>(ptr + 8 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4, checksumSize, 
					"8 + 4 + 4 + 4 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glBlendColor(%f %f %f %f )", stream,var_red, var_green, var_blue, var_alpha);
			this->glBlendColor(var_red, var_green, var_blue, var_alpha);
			SET_LASTCALL("glBlendColor");
			break;
		}
		case OP_glBlendEquation: {
			GLenum var_mode = Unpack<GLenum,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"8 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glBlendEquation(0x%08x )", stream,var_mode);
			this->glBlendEquation(var_mode);
			SET_LASTCALL("glBlendEquation");
			break;
		}
		case OP_glBlendEquationSeparate: {
			GLenum var_modeRGB = Unpack<GLenum,uint32_t>(ptr + 8);
			GLenum var_modeAlpha = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize, 
					"8 + 4 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glBlendEquationSeparate(0x%08x 0x%08x )", stream,var_modeRGB, var_modeAlpha);
			this->glBlendEquationSeparate(var_modeRGB, var_modeAlpha);
			SET_LASTCALL("glBlendEquationSeparate");
			break;
		}
		case OP_glBlendFunc: {
			GLenum var_sfactor = Unpack<GLenum,uint32_t>(ptr + 8);
			GLenum var_dfactor = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize, 
					"8 + 4 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glBlendFunc(0x%08x 0x%08x )", stream,var_sfactor, var_dfactor);
			this->glBlendFunc(var_sfactor, var_dfactor);
			SET_LASTCALL("glBlendFunc");
			break;
		}
		case OP_glBlendFuncSeparate: {
			GLenum var_srcRGB = Unpack<GLenum,uint32_t>(ptr + 8);
			GLenum var_dstRGB = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			GLenum var_srcAlpha = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4);
			GLenum var_dstAlpha = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4, checksumSize, 
					"8 + 4 + 4 + 4 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glBlendFuncSeparate(0x%08x 0x%08x 0x%08x 0x%08x )", stream,var_srcRGB, var_dstRGB, var_srcAlpha, var_dstAlpha);
			this->glBlendFuncSeparate(var_srcRGB, var_dstRGB, var_srcAlpha, var_dstAlpha);
			SET_LASTCALL("glBlendFuncSeparate");
			break;
		}
		case OP_glBufferData: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLsizeiptr var_size = Unpack<GLsizeiptr,uint32_t>(ptr + 8 + 4);
			uint32_t size_data  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			InputBuffer inptr_data(ptr + 8 + 4 + 4 + 4, size_data);
			GLenum var_usage = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4 + 4 + size_data);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4 + size_data + 4, ptr + 8 + 4 + 4 + 4 + size_data + 4, checksumSize, 
					"8 + 4 + 4 + 4 + size_data + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glBufferData(0x%08x %p %p(%u) 0x%08x )", stream,var_target, var_size, (const GLvoid*)(inptr_data.get()), size_data, var_usage);
			this->glBufferData(var_target, var_size, size_data == 0 ? NULL : (const GLvoid*)(inptr_data.get()), var_usage);
			SET_LASTCALL("glBufferData");
			break;
		}
		case OP_glBufferSubData: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLintptr var_offset = Unpack<GLintptr,uint32_t>(ptr + 8 + 4);
			GLsizeiptr var_size = Unpack<GLsizeiptr,uint32_t>(ptr + 8 + 4 + 4);
			uint32_t size_data  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4);
			InputBuffer inptr_data(ptr + 8 + 4 + 4 + 4 + 4, size_data);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4 + 4 + size_data, ptr + 8 + 4 + 4 + 4 + 4 + size_data, checksumSize, 
					"8 + 4 + 4 + 4 + 4 + size_data::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glBufferSubData(0x%08x %p %p %p(%u) )", stream,var_target, var_offset, var_size, (const GLvoid*)(inptr_data.get()), size_data);
			this->glBufferSubData(var_target, var_offset, var_size, size_data == 0 ? NULL : (const GLvoid*)(inptr_data.get()));
			SET_LASTCALL("glBufferSubData");
			break;
		}
		case OP_glCheckFramebufferStatus: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"8 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(GLenum);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			DEBUG("gles2(%p): glCheckFramebufferStatus(0x%08x )", stream,var_target);
			*(GLenum *)(&tmpBuf[0]) = 			this->glCheckFramebufferStatus(var_target);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(&tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glCheckFramebufferStatus");
			break;
		}
		case OP_glClear: {
			GLbitfield var_mask = Unpack<GLbitfield,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"8 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glClear(0x%08x )", stream,var_mask);
			this->glClear(var_mask);
			SET_LASTCALL("glClear");
			break;
		}
		case OP_glClearColor: {
			GLclampf var_red = Unpack<GLclampf,uint32_t>(ptr + 8);
			GLclampf var_green = Unpack<GLclampf,uint32_t>(ptr + 8 + 4);
			GLclampf var_blue = Unpack<GLclampf,uint32_t>(ptr + 8 + 4 + 4);
			GLclampf var_alpha = Unpack<GLclampf,uint32_t>(ptr + 8 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4, checksumSize, 
					"8 + 4 + 4 + 4 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glClearColor(%f %f %f %f )", stream,var_red, var_green, var_blue, var_alpha);
			this->glClearColor(var_red, var_green, var_blue, var_alpha);
			SET_LASTCALL("glClearColor");
			break;
		}
		case OP_glClearDepthf: {
			GLclampf var_depth = Unpack<GLclampf,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"8 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glClearDepthf(%f )", stream,var_depth);
			this->glClearDepthf(var_depth);
			SET_LASTCALL("glClearDepthf");
			break;
		}
		case OP_glClearStencil: {
			GLint var_s = Unpack<GLint,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"8 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glClearStencil(%d )", stream,var_s);
			this->glClearStencil(var_s);
			SET_LASTCALL("glClearStencil");
			break;
		}
		case OP_glColorMask: {
			GLboolean var_red = Unpack<GLboolean,uint8_t>(ptr + 8);
			GLboolean var_green = Unpack<GLboolean,uint8_t>(ptr + 8 + 1);
			GLboolean var_blue = Unpack<GLboolean,uint8_t>(ptr + 8 + 1 + 1);
			GLboolean var_alpha = Unpack<GLboolean,uint8_t>(ptr + 8 + 1 + 1 + 1);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 1 + 1 + 1 + 1, ptr + 8 + 1 + 1 + 1 + 1, checksumSize, 
					"8 + 1 + 1 + 1 + 1::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glColorMask(%d %d %d %d )", stream,var_red, var_green, var_blue, var_alpha);
			this->glColorMask(var_red, var_green, var_blue, var_alpha);
			SET_LASTCALL("glColorMask");
			break;
		}
		case OP_glCompileShader: {
			GLuint var_shader = Unpack<GLuint,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"8 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glCompileShader(%u )", stream,var_shader);
			this->glCompileShader(var_shader);
			SET_LASTCALL("glCompileShader");
			break;
		}
		case OP_glCompressedTexImage2D: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLint var_level = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLenum var_internalformat = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4);
			GLsizei var_width = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4);
			GLsizei var_height = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			GLint var_border = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4);
			GLsizei var_imageSize = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4);
			uint32_t size_data  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			InputBuffer inptr_data(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4, size_data);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + size_data, ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + size_data, checksumSize, 
					"8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + size_data::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glCompressedTexImage2D(0x%08x %d 0x%08x %d %d %d %d %p(%u) )", stream,var_target, var_level, var_internalformat, var_width, var_height, var_border, var_imageSize, (const GLvoid*)(inptr_data.get()), size_data);
			this->glCompressedTexImage2D(var_target, var_level, var_internalformat, var_width, var_height, var_border, var_imageSize, size_data == 0 ? NULL : (const GLvoid*)(inptr_data.get()));
			SET_LASTCALL("glCompressedTexImage2D");
			break;
		}
		case OP_glCompressedTexSubImage2D: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLint var_level = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLint var_xoffset = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4);
			GLint var_yoffset = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4);
			GLsizei var_width = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			GLsizei var_height = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4);
			GLenum var_format = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4);
			GLsizei var_imageSize = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			uint32_t size_data  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			InputBuffer inptr_data(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4, size_data);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + size_data, ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + size_data, checksumSize, 
					"8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + size_data::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glCompressedTexSubImage2D(0x%08x %d %d %d %d %d 0x%08x %d %p(%u) )", stream,var_target, var_level, var_xoffset, var_yoffset, var_width, var_height, var_format, var_imageSize, (const GLvoid*)(inptr_data.get()), size_data);
			this->glCompressedTexSubImage2D(var_target, var_level, var_xoffset, var_yoffset, var_width, var_height, var_format, var_imageSize, size_data == 0 ? NULL : (const GLvoid*)(inptr_data.get()));
			SET_LASTCALL("glCompressedTexSubImage2D");
			break;
		}
		case OP_glCopyTexImage2D: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLint var_level = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLenum var_internalformat = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4);
			GLint var_x = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4);
			GLint var_y = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			GLsizei var_width = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4);
			GLsizei var_height = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4);
			GLint var_border = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4, checksumSize, 
					"8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glCopyTexImage2D(0x%08x %d 0x%08x %d %d %d %d %d )", stream,var_target, var_level, var_internalformat, var_x, var_y, var_width, var_height, var_border);
			this->glCopyTexImage2D(var_target, var_level, var_internalformat, var_x, var_y, var_width, var_height, var_border);
			SET_LASTCALL("glCopyTexImage2D");
			break;
		}
		case OP_glCopyTexSubImage2D: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLint var_level = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLint var_xoffset = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4);
			GLint var_yoffset = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4);
			GLint var_x = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			GLint var_y = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4);
			GLsizei var_width = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4);
			GLsizei var_height = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4, checksumSize, 
					"8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glCopyTexSubImage2D(0x%08x %d %d %d %d %d %d %d )", stream,var_target, var_level, var_xoffset, var_yoffset, var_x, var_y, var_width, var_height);
			this->glCopyTexSubImage2D(var_target, var_level, var_xoffset, var_yoffset, var_x, var_y, var_width, var_height);
			SET_LASTCALL("glCopyTexSubImage2D");
			break;
		}
		case OP_glCreateProgram: {
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8, ptr + 8, checksumSize, 
					"8::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(GLuint);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			DEBUG("gles2(%p): glCreateProgram()", stream);
			*(GLuint *)(&tmpBuf[0]) = 			this->glCreateProgram();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(&tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glCreateProgram");
			break;
		}
		case OP_glCreateShader: {
			GLenum var_type = Unpack<GLenum,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"8 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(GLuint);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			DEBUG("gles2(%p): glCreateShader(0x%08x )", stream,var_type);
			*(GLuint *)(&tmpBuf[0]) = 			this->glCreateShader(var_type);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(&tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glCreateShader");
			break;
		}
		case OP_glCullFace: {
			GLenum var_mode = Unpack<GLenum,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"8 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glCullFace(0x%08x )", stream,var_mode);
			this->glCullFace(var_mode);
			SET_LASTCALL("glCullFace");
			break;
		}
		case OP_glDeleteBuffers: {
			GLsizei var_n = Unpack<GLsizei,uint32_t>(ptr + 8);
			uint32_t size_buffers  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			InputBuffer inptr_buffers(ptr + 8 + 4 + 4, size_buffers);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + size_buffers, ptr + 8 + 4 + 4 + size_buffers, checksumSize, 
					"8 + 4 + 4 + size_buffers::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glDeleteBuffers(%d %p(%u) )", stream,var_n, (const GLuint*)(inptr_buffers.get()), size_buffers);
			this->glDeleteBuffers(var_n, (const GLuint*)(inptr_buffers.get()));
			SET_LASTCALL("glDeleteBuffers");
			break;
		}
		case OP_glDeleteFramebuffers: {
			GLsizei var_n = Unpack<GLsizei,uint32_t>(ptr + 8);
			uint32_t size_framebuffers  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			InputBuffer inptr_framebuffers(ptr + 8 + 4 + 4, size_framebuffers);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + size_framebuffers, ptr + 8 + 4 + 4 + size_framebuffers, checksumSize, 
					"8 + 4 + 4 + size_framebuffers::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glDeleteFramebuffers(%d %p(%u) )", stream,var_n, (const GLuint*)(inptr_framebuffers.get()), size_framebuffers);
			this->glDeleteFramebuffers(var_n, (const GLuint*)(inptr_framebuffers.get()));
			SET_LASTCALL("glDeleteFramebuffers");
			break;
		}
		case OP_glDeleteProgram: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"8 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glDeleteProgram(%u )", stream,var_program);
			this->glDeleteProgram(var_program);
			SET_LASTCALL("glDeleteProgram");
			m_lock.lock(); 
			auto pro = m_programs.find(var_program); 
			if (pro != m_programs.end()) 
			{ 
				m_programs.erase(pro); 
			}
			m_lock.unlock();
			break;
		}
		case OP_glDeleteRenderbuffers: {
			GLsizei var_n = Unpack<GLsizei,uint32_t>(ptr + 8);
			uint32_t size_renderbuffers  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			InputBuffer inptr_renderbuffers(ptr + 8 + 4 + 4, size_renderbuffers);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + size_renderbuffers, ptr + 8 + 4 + 4 + size_renderbuffers, checksumSize, 
					"8 + 4 + 4 + size_renderbuffers::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glDeleteRenderbuffers(%d %p(%u) )", stream,var_n, (const GLuint*)(inptr_renderbuffers.get()), size_renderbuffers);
			this->glDeleteRenderbuffers(var_n, (const GLuint*)(inptr_renderbuffers.get()));
			SET_LASTCALL("glDeleteRenderbuffers");
			break;
		}
		case OP_glDeleteShader: {
			GLuint var_shader = Unpack<GLuint,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"8 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glDeleteShader(%u )", stream,var_shader);
			this->glDeleteShader(var_shader);
			SET_LASTCALL("glDeleteShader");
			m_lock.lock(); 
						auto shader = m_shaders.find(var_shader); 
						if (shader != m_shaders.end()) 
						{ 
							m_shaders.erase(shader); 
						} 
						m_lock.unlock(); 
			break;
		}
		case OP_glDeleteTextures: {
			GLsizei var_n = Unpack<GLsizei,uint32_t>(ptr + 8);
			uint32_t size_textures  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			InputBuffer inptr_textures(ptr + 8 + 4 + 4, size_textures);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + size_textures, ptr + 8 + 4 + 4 + size_textures, checksumSize, 
					"8 + 4 + 4 + size_textures::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glDeleteTextures(%d %p(%u) )", stream,var_n, (const GLuint*)(inptr_textures.get()), size_textures);
			this->glDeleteTextures(var_n, (const GLuint*)(inptr_textures.get()));
			SET_LASTCALL("glDeleteTextures");
			break;
		}
		case OP_glDepthFunc: {
			GLenum var_func = Unpack<GLenum,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"8 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glDepthFunc(0x%08x )", stream,var_func);
			this->glDepthFunc(var_func);
			SET_LASTCALL("glDepthFunc");
			break;
		}
		case OP_glDepthMask: {
			GLboolean var_flag = Unpack<GLboolean,uint8_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 1, ptr + 8 + 1, checksumSize, 
					"8 + 1::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glDepthMask(%d )", stream,var_flag);
			this->glDepthMask(var_flag);
			SET_LASTCALL("glDepthMask");
			break;
		}
		case OP_glDepthRangef: {
			GLclampf var_zNear = Unpack<GLclampf,uint32_t>(ptr + 8);
			GLclampf var_zFar = Unpack<GLclampf,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize, 
					"8 + 4 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glDepthRangef(%f %f )", stream,var_zNear, var_zFar);
			this->glDepthRangef(var_zNear, var_zFar);
			SET_LASTCALL("glDepthRangef");
			break;
		}
		case OP_glDetachShader: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			GLuint var_shader = Unpack<GLuint,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize, 
					"8 + 4 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glDetachShader(%u %u )", stream,var_program, var_shader);
			this->glDetachShader(var_program, var_shader);
			SET_LASTCALL("glDetachShader");
			break;
		}
		case OP_glDisable: {
			GLenum var_cap = Unpack<GLenum,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"8 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glDisable(0x%08x )", stream,var_cap);
			this->glDisable(var_cap);
			SET_LASTCALL("glDisable");
			break;
		}
		case OP_glDisableVertexAttribArray: {
			GLuint var_index = Unpack<GLuint,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"8 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glDisableVertexAttribArray(%u )", stream,var_index);
			this->glDisableVertexAttribArray(var_index);
			SET_LASTCALL("glDisableVertexAttribArray");
			break;
		}
		case OP_glDrawArrays: {
			GLenum var_mode = Unpack<GLenum,uint32_t>(ptr + 8);
			GLint var_first = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLsizei var_count = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4, checksumSize, 
					"8 + 4 + 4 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glDrawArrays(0x%08x %d %d )", stream,var_mode, var_first, var_count);
			this->glDrawArrays(var_mode, var_first, var_count);
			SET_LASTCALL("glDrawArrays");
			break;
		}
		case OP_glDrawElements: {
			GLenum var_mode = Unpack<GLenum,uint32_t>(ptr + 8);
			GLsizei var_count = Unpack<GLsizei,uint32_t>(ptr + 8 + 4);
			GLenum var_type = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4);
			uint32_t size_indices  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4);
			InputBuffer inptr_indices(ptr + 8 + 4 + 4 + 4 + 4, size_indices);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4 + 4 + size_indices, ptr + 8 + 4 + 4 + 4 + 4 + size_indices, checksumSize, 
					"8 + 4 + 4 + 4 + 4 + size_indices::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glDrawElements(0x%08x %d 0x%08x %p(%u) )", stream,var_mode, var_count, var_type, (const GLvoid*)(inptr_indices.get()), size_indices);
			this->glDrawElements(var_mode, var_count, var_type, (const GLvoid*)(inptr_indices.get()));
			SET_LASTCALL("glDrawElements");
			break;
		}
		case OP_glEnable: {
			GLenum var_cap = Unpack<GLenum,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"8 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glEnable(0x%08x )", stream,var_cap);
			this->glEnable(var_cap);
			SET_LASTCALL("glEnable");
			break;
		}
		case OP_glEnableVertexAttribArray: {
			GLuint var_index = Unpack<GLuint,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"8 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glEnableVertexAttribArray(%u )", stream,var_index);
			this->glEnableVertexAttribArray(var_index);
			SET_LASTCALL("glEnableVertexAttribArray");
			break;
		}
		case OP_glFinish: {
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8, ptr + 8, checksumSize, 
					"8::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glFinish()", stream);
			this->glFinish();
			SET_LASTCALL("glFinish");
			break;
		}
		case OP_glFlush: {
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8, ptr + 8, checksumSize, 
					"8::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glFlush()", stream);
			this->glFlush();
			SET_LASTCALL("glFlush");
			break;
		}
		case OP_glFramebufferRenderbuffer: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLenum var_attachment = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			GLenum var_renderbuffertarget = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4);
			GLuint var_renderbuffer = Unpack<GLuint,uint32_t>(ptr + 8 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4, checksumSize, 
					"8 + 4 + 4 + 4 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glFramebufferRenderbuffer(0x%08x 0x%08x 0x%08x %u )", stream,var_target, var_attachment, var_renderbuffertarget, var_renderbuffer);
			this->glFramebufferRenderbuffer(var_target, var_attachment, var_renderbuffertarget, var_renderbuffer);
			SET_LASTCALL("glFramebufferRenderbuffer");
			break;
		}
		case OP_glFramebufferTexture2D: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLenum var_attachment = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			GLenum var_textarget = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4);
			GLuint var_texture = Unpack<GLuint,uint32_t>(ptr + 8 + 4 + 4 + 4);
			GLint var_level = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4 + 4, checksumSize, 
					"8 + 4 + 4 + 4 + 4 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glFramebufferTexture2D(0x%08x 0x%08x 0x%08x %u %d )", stream,var_target, var_attachment, var_textarget, var_texture, var_level);
			this->glFramebufferTexture2D(var_target, var_attachment, var_textarget, var_texture, var_level);
			SET_LASTCALL("glFramebufferTexture2D");
			break;
		}
		case OP_glFrontFace: {
			GLenum var_mode = Unpack<GLenum,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"8 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glFrontFace(0x%08x )", stream,var_mode);
			this->glFrontFace(var_mode);
			SET_LASTCALL("glFrontFace");
			break;
		}
		case OP_glGenBuffers: {
			GLsizei var_n = Unpack<GLsizei,uint32_t>(ptr + 8);
			uint32_t size_buffers  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize, 
					"8 + 4 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_buffers;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_buffers(&tmpBuf[0], size_buffers);
			DEBUG("gles2(%p): glGenBuffers(%d %p(%u) )", stream,var_n, (GLuint*)(outptr_buffers.get()), size_buffers);
			this->glGenBuffers(var_n, (GLuint*)(outptr_buffers.get()));
			outptr_buffers.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(&tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGenBuffers");
			break;
		}
		case OP_glGenerateMipmap: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"8 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glGenerateMipmap(0x%08x )", stream,var_target);
			this->glGenerateMipmap(var_target);
			SET_LASTCALL("glGenerateMipmap");
			break;
		}
		case OP_glGenFramebuffers: {
			GLsizei var_n = Unpack<GLsizei,uint32_t>(ptr + 8);
			uint32_t size_framebuffers  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize, 
					"8 + 4 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_framebuffers;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_framebuffers(&tmpBuf[0], size_framebuffers);
			DEBUG("gles2(%p): glGenFramebuffers(%d %p(%u) )", stream,var_n, (GLuint*)(outptr_framebuffers.get()), size_framebuffers);
			this->glGenFramebuffers(var_n, (GLuint*)(outptr_framebuffers.get()));
			outptr_framebuffers.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(&tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGenFramebuffers");
			break;
		}
		case OP_glGenRenderbuffers: {
			GLsizei var_n = Unpack<GLsizei,uint32_t>(ptr + 8);
			uint32_t size_renderbuffers  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize, 
					"8 + 4 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_renderbuffers;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_renderbuffers(&tmpBuf[0], size_renderbuffers);
			DEBUG("gles2(%p): glGenRenderbuffers(%d %p(%u) )", stream,var_n, (GLuint*)(outptr_renderbuffers.get()), size_renderbuffers);
			this->glGenRenderbuffers(var_n, (GLuint*)(outptr_renderbuffers.get()));
			outptr_renderbuffers.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(&tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGenRenderbuffers");
			break;
		}
		case OP_glGenTextures: {
			GLsizei var_n = Unpack<GLsizei,uint32_t>(ptr + 8);
			uint32_t size_textures  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize, 
					"8 + 4 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_textures;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_textures(&tmpBuf[0], size_textures);
			DEBUG("gles2(%p): glGenTextures(%d %p(%u) )", stream,var_n, (GLuint*)(outptr_textures.get()), size_textures);
			this->glGenTextures(var_n, (GLuint*)(outptr_textures.get()));
			outptr_textures.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(&tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGenTextures");
			break;
		}
		case OP_glGetActiveAttrib: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			GLuint var_index = Unpack<GLuint,uint32_t>(ptr + 8 + 4);
			GLsizei var_bufsize = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4);
			uint32_t size_length  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4);
			uint32_t size_size  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			uint32_t size_type  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4);
			uint32_t size_name  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4, checksumSize, 
					"8 + 4 + 4 + 4 + 4 + 4 + 4 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_length;
			totalTmpSize += size_size;
			totalTmpSize += size_type;
			totalTmpSize += size_name;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_length(&tmpBuf[0], size_length);
			OutputBuffer outptr_size(&tmpBuf[0 + size_length], size_size);
			OutputBuffer outptr_type(&tmpBuf[0 + size_length + size_size], size_type);
			OutputBuffer outptr_name(&tmpBuf[0 + size_length + size_size + size_type], size_name);
			DEBUG("gles2(%p): glGetActiveAttrib(%u %u %d %p(%u) %p(%u) %p(%u) %p(%u) )", stream,var_program, var_index, var_bufsize, (GLsizei*)(outptr_length.get()), size_length, (GLint*)(outptr_size.get()), size_size, (GLenum*)(outptr_type.get()), size_type, (GLchar*)(outptr_name.get()), size_name);
			this->glGetActiveAttrib(var_program, var_index, var_bufsize, size_length == 0 ? NULL : (GLsizei*)(outptr_length.get()), size_size == 0 ? NULL : (GLint*)(outptr_size.get()), size_type == 0 ? NULL : (GLenum*)(outptr_type.get()), size_name == 0 ? NULL : (GLchar*)(outptr_name.get()));
			outptr_length.flush();
			outptr_size.flush();
			outptr_type.flush();
			outptr_name.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(&tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGetActiveAttrib");
			break;
		}
		case OP_glGetActiveUniform: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			GLuint var_index = Unpack<GLuint,uint32_t>(ptr + 8 + 4);
			GLsizei var_bufsize = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4);
			uint32_t size_length  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4);
			uint32_t size_size  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			uint32_t size_type  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4);
			uint32_t size_name  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4, checksumSize, 
					"8 + 4 + 4 + 4 + 4 + 4 + 4 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_length;
			totalTmpSize += size_size;
			totalTmpSize += size_type;
			totalTmpSize += size_name;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_length(&tmpBuf[0], size_length);
			OutputBuffer outptr_size(&tmpBuf[0 + size_length], size_size);
			OutputBuffer outptr_type(&tmpBuf[0 + size_length + size_size], size_type);
			OutputBuffer outptr_name(&tmpBuf[0 + size_length + size_size + size_type], size_name);
			DEBUG("gles2(%p): glGetActiveUniform(%u %u %d %p(%u) %p(%u) %p(%u) %p(%u) )", stream,var_program, var_index, var_bufsize, (GLsizei*)(outptr_length.get()), size_length, (GLint*)(outptr_size.get()), size_size, (GLenum*)(outptr_type.get()), size_type, (GLchar*)(outptr_name.get()), size_name);
			this->glGetActiveUniform(var_program, var_index, var_bufsize, size_length == 0 ? NULL : (GLsizei*)(outptr_length.get()), size_size == 0 ? NULL : (GLint*)(outptr_size.get()), size_type == 0 ? NULL : (GLenum*)(outptr_type.get()), size_name == 0 ? NULL : (GLchar*)(outptr_name.get()));
			outptr_length.flush();
			outptr_size.flush();
			outptr_type.flush();
			outptr_name.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(&tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGetActiveUniform");
			break;
		}
		case OP_glGetAttachedShaders: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			GLsizei var_maxcount = Unpack<GLsizei,uint32_t>(ptr + 8 + 4);
			uint32_t size_count  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			uint32_t size_shaders  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4, checksumSize, 
					"8 + 4 + 4 + 4 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_count;
			totalTmpSize += size_shaders;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_count(&tmpBuf[0], size_count);
			OutputBuffer outptr_shaders(&tmpBuf[0 + size_count], size_shaders);
			DEBUG("gles2(%p): glGetAttachedShaders(%u %d %p(%u) %p(%u) )", stream,var_program, var_maxcount, (GLsizei*)(outptr_count.get()), size_count, (GLuint*)(outptr_shaders.get()), size_shaders);
			this->glGetAttachedShaders(var_program, var_maxcount, size_count == 0 ? NULL : (GLsizei*)(outptr_count.get()), (GLuint*)(outptr_shaders.get()));
			outptr_count.flush();
			outptr_shaders.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(&tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGetAttachedShaders");
			break;
		}
		case OP_glGetAttribLocation: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			uint32_t size_name  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			InputBuffer inptr_name(ptr + 8 + 4 + 4, size_name);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + size_name, ptr + 8 + 4 + 4 + size_name, checksumSize, 
					"8 + 4 + 4 + size_name::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(int);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			DEBUG("gles2(%p): glGetAttribLocation(%u %p(%u) )", stream,var_program, (const GLchar*)(inptr_name.get()), size_name);
			*(int *)(&tmpBuf[0]) = 			this->glGetAttribLocation(var_program, (const GLchar*)(inptr_name.get()));
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(&tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGetAttribLocation");
			break;
		}
		case OP_glGetBooleanv: {
			GLenum var_pname = Unpack<GLenum,uint32_t>(ptr + 8);
			uint32_t size_params  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize, 
					"8 + 4 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_params;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_params(&tmpBuf[0], size_params);
			DEBUG("gles2(%p): glGetBooleanv(0x%08x %p(%u) )", stream,var_pname, (GLboolean*)(outptr_params.get()), size_params);
			this->glGetBooleanv(var_pname, (GLboolean*)(outptr_params.get()));
			outptr_params.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(&tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGetBooleanv");
			break;
		}
		case OP_glGetBufferParameteriv: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLenum var_pname = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			uint32_t size_params  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4, checksumSize, 
					"8 + 4 + 4 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_params;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_params(&tmpBuf[0], size_params);
			DEBUG("gles2(%p): glGetBufferParameteriv(0x%08x 0x%08x %p(%u) )", stream,var_target, var_pname, (GLint*)(outptr_params.get()), size_params);
			this->glGetBufferParameteriv(var_target, var_pname, (GLint*)(outptr_params.get()));
			outptr_params.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(&tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGetBufferParameteriv");
			break;
		}
		case OP_glGetError: {
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8, ptr + 8, checksumSize, 
					"8::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(GLenum);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			DEBUG("gles2(%p): glGetError()", stream);
			*(GLenum *)(&tmpBuf[0]) = 			this->glGetError();
			printf("error: %d", *(GLenum*)(&tmpBuf[0]));
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(&tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGetError");
			break;
		}
		case OP_glGetFloatv: {
			GLenum var_pname = Unpack<GLenum,uint32_t>(ptr + 8);
			uint32_t size_params  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize, 
					"8 + 4 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_params;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_params(&tmpBuf[0], size_params);
			DEBUG("gles2(%p): glGetFloatv(0x%08x %p(%u) )", stream,var_pname, (GLfloat*)(outptr_params.get()), size_params);
			this->glGetFloatv(var_pname, (GLfloat*)(outptr_params.get()));
			outptr_params.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(&tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGetFloatv");
			break;
		}
		case OP_glGetFramebufferAttachmentParameteriv: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLenum var_attachment = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			GLenum var_pname = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4);
			uint32_t size_params  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4, checksumSize, 
					"8 + 4 + 4 + 4 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_params;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_params(&tmpBuf[0], size_params);
			DEBUG("gles2(%p): glGetFramebufferAttachmentParameteriv(0x%08x 0x%08x 0x%08x %p(%u) )", stream,var_target, var_attachment, var_pname, (GLint*)(outptr_params.get()), size_params);
			this->glGetFramebufferAttachmentParameteriv(var_target, var_attachment, var_pname, (GLint*)(outptr_params.get()));
			outptr_params.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(&tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGetFramebufferAttachmentParameteriv");
			break;
		}
		case OP_glGetIntegerv: {
			GLenum var_pname = Unpack<GLenum,uint32_t>(ptr + 8);
			uint32_t size_params  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize, 
					"8 + 4 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_params;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_params(&tmpBuf[0], size_params);
			DEBUG("gles2(%p): glGetIntegerv(0x%08x %p(%u) )", stream,var_pname, (GLint*)(outptr_params.get()), size_params);
			this->glGetIntegerv(var_pname, (GLint*)(outptr_params.get()));
			outptr_params.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(&tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGetIntegerv");
			break;
		}
		case OP_glGetProgramiv: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			GLenum var_pname = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			uint32_t size_params  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4, checksumSize, 
					"8 + 4 + 4 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_params;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_params(&tmpBuf[0], size_params);
			DEBUG("gles2(%p): glGetProgramiv(%u 0x%08x %p(%u) )", stream,var_program, var_pname, (GLint*)(outptr_params.get()), size_params);
			this->glGetProgramiv(var_program, var_pname, (GLint*)(outptr_params.get()));
			outptr_params.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(&tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGetProgramiv");
			break;
		}
		case OP_glGetProgramInfoLog: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			GLsizei var_bufsize = Unpack<GLsizei,uint32_t>(ptr + 8 + 4);
			uint32_t size_length  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			uint32_t size_infolog  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4, checksumSize, 
					"8 + 4 + 4 + 4 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_length;
			totalTmpSize += size_infolog;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_length(&tmpBuf[0], size_length);
			OutputBuffer outptr_infolog(&tmpBuf[0 + size_length], size_infolog);
			DEBUG("gles2(%p): glGetProgramInfoLog(%u %d %p(%u) %p(%u) )", stream,var_program, var_bufsize, (GLsizei*)(outptr_length.get()), size_length, (GLchar*)(outptr_infolog.get()), size_infolog);
			this->glGetProgramInfoLog(var_program, var_bufsize, size_length == 0 ? NULL : (GLsizei*)(outptr_length.get()), (GLchar*)(outptr_infolog.get()));
			outptr_length.flush();
			outptr_infolog.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(&tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGetProgramInfoLog");
			break;
		}
		case OP_glGetRenderbufferParameteriv: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLenum var_pname = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			uint32_t size_params  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4, checksumSize, 
					"8 + 4 + 4 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_params;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_params(&tmpBuf[0], size_params);
			DEBUG("gles2(%p): glGetRenderbufferParameteriv(0x%08x 0x%08x %p(%u) )", stream,var_target, var_pname, (GLint*)(outptr_params.get()), size_params);
			this->glGetRenderbufferParameteriv(var_target, var_pname, (GLint*)(outptr_params.get()));
			outptr_params.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(&tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGetRenderbufferParameteriv");
			break;
		}
		case OP_glGetShaderiv: {
			GLuint var_shader = Unpack<GLuint,uint32_t>(ptr + 8);
			GLenum var_pname = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			uint32_t size_params  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4, checksumSize, 
					"8 + 4 + 4 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_params;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_params(&tmpBuf[0], size_params);
			DEBUG("gles2(%p): glGetShaderiv(%u 0x%08x %p(%u) )", stream,var_shader, var_pname, (GLint*)(outptr_params.get()), size_params);
			this->glGetShaderiv(var_shader, var_pname, (GLint*)(outptr_params.get()));
			outptr_params.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(&tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGetShaderiv");
			break;
		}
		case OP_glGetShaderInfoLog: {
			GLuint var_shader = Unpack<GLuint,uint32_t>(ptr + 8);
			GLsizei var_bufsize = Unpack<GLsizei,uint32_t>(ptr + 8 + 4);
			uint32_t size_length  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			uint32_t size_infolog  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4, checksumSize, 
					"8 + 4 + 4 + 4 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_length;
			totalTmpSize += size_infolog;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_length(&tmpBuf[0], size_length);
			OutputBuffer outptr_infolog(&tmpBuf[0 + size_length], size_infolog);
			DEBUG("gles2(%p): glGetShaderInfoLog(%u %d %p(%u) %p(%u) )", stream,var_shader, var_bufsize, (GLsizei*)(outptr_length.get()), size_length, (GLchar*)(outptr_infolog.get()), size_infolog);
			this->glGetShaderInfoLog(var_shader, var_bufsize, size_length == 0 ? NULL : (GLsizei*)(outptr_length.get()), (GLchar*)(outptr_infolog.get()));
			outptr_length.flush();
			outptr_infolog.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(&tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGetShaderInfoLog");
			break;
		}
		case OP_glGetShaderPrecisionFormat: {
			GLenum var_shadertype = Unpack<GLenum,uint32_t>(ptr + 8);
			GLenum var_precisiontype = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			uint32_t size_range  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			uint32_t size_precision  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4, checksumSize, 
					"8 + 4 + 4 + 4 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_range;
			totalTmpSize += size_precision;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_range(&tmpBuf[0], size_range);
			OutputBuffer outptr_precision(&tmpBuf[0 + size_range], size_precision);
			DEBUG("gles2(%p): glGetShaderPrecisionFormat(0x%08x 0x%08x %p(%u) %p(%u) )", stream,var_shadertype, var_precisiontype, (GLint*)(outptr_range.get()), size_range, (GLint*)(outptr_precision.get()), size_precision);
			this->glGetShaderPrecisionFormat(var_shadertype, var_precisiontype, (GLint*)(outptr_range.get()), (GLint*)(outptr_precision.get()));
			outptr_range.flush();
			outptr_precision.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(&tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGetShaderPrecisionFormat");
			break;
		}
		case OP_glGetShaderSource: {
			GLuint var_shader = Unpack<GLuint,uint32_t>(ptr + 8);
			GLsizei var_bufsize = Unpack<GLsizei,uint32_t>(ptr + 8 + 4);
			uint32_t size_length  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			uint32_t size_source  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4, checksumSize, 
					"8 + 4 + 4 + 4 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_length;
			totalTmpSize += size_source;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_length(&tmpBuf[0], size_length);
			OutputBuffer outptr_source(&tmpBuf[0 + size_length], size_source);
			DEBUG("gles2(%p): glGetShaderSource(%u %d %p(%u) %p(%u) )", stream,var_shader, var_bufsize, (GLsizei*)(outptr_length.get()), size_length, (GLchar*)(outptr_source.get()), size_source);
			this->glGetShaderSource(var_shader, var_bufsize, size_length == 0 ? NULL : (GLsizei*)(outptr_length.get()), (GLchar*)(outptr_source.get()));
			outptr_length.flush();
			outptr_source.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(&tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGetShaderSource");
			break;
		}
		case OP_glGetString: {
			GLenum var_name = Unpack<GLenum,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"8 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glGetString(0x%08x )", stream,var_name);
			this->glGetString(var_name);
			SET_LASTCALL("glGetString");
			break;
		}
		case OP_glGetTexParameterfv: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLenum var_pname = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			uint32_t size_params  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4, checksumSize, 
					"8 + 4 + 4 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_params;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_params(&tmpBuf[0], size_params);
			DEBUG("gles2(%p): glGetTexParameterfv(0x%08x 0x%08x %p(%u) )", stream,var_target, var_pname, (GLfloat*)(outptr_params.get()), size_params);
			this->glGetTexParameterfv(var_target, var_pname, (GLfloat*)(outptr_params.get()));
			outptr_params.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(&tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGetTexParameterfv");
			break;
		}
		case OP_glGetTexParameteriv: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLenum var_pname = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			uint32_t size_params  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4, checksumSize, 
					"8 + 4 + 4 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_params;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_params(&tmpBuf[0], size_params);
			DEBUG("gles2(%p): glGetTexParameteriv(0x%08x 0x%08x %p(%u) )", stream,var_target, var_pname, (GLint*)(outptr_params.get()), size_params);
			this->glGetTexParameteriv(var_target, var_pname, (GLint*)(outptr_params.get()));
			outptr_params.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(&tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGetTexParameteriv");
			break;
		}
		case OP_glGetUniformfv: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			uint32_t size_params  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4, checksumSize, 
					"8 + 4 + 4 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_params;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_params(&tmpBuf[0], size_params);
			DEBUG("gles2(%p): glGetUniformfv(%u %d %p(%u) )", stream,var_program, var_location, (GLfloat*)(outptr_params.get()), size_params);
			this->glGetUniformfv(var_program, var_location, (GLfloat*)(outptr_params.get()));
			outptr_params.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(&tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGetUniformfv");
			break;
		}
		case OP_glGetUniformiv: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			uint32_t size_params  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4, checksumSize, 
					"8 + 4 + 4 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_params;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_params(&tmpBuf[0], size_params);
			DEBUG("gles2(%p): glGetUniformiv(%u %d %p(%u) )", stream,var_program, var_location, (GLint*)(outptr_params.get()), size_params);
			this->glGetUniformiv(var_program, var_location, (GLint*)(outptr_params.get()));
			outptr_params.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(&tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGetUniformiv");
			break;
		}
		case OP_glGetUniformLocation: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			uint32_t size_name  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			InputBuffer inptr_name(ptr + 8 + 4 + 4, size_name);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + size_name, ptr + 8 + 4 + 4 + size_name, checksumSize, 
					"8 + 4 + 4 + size_name::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(int);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			DEBUG("gles2(%p): glGetUniformLocation(%u %p(%u) )", stream,var_program, (const GLchar*)(inptr_name.get()), size_name);
			*(int *)(&tmpBuf[0]) = 			this->glGetUniformLocation(var_program, (const GLchar*)(inptr_name.get()));
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(&tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGetUniformLocation");
			break;
		}
		case OP_glGetVertexAttribfv: {
			GLuint var_index = Unpack<GLuint,uint32_t>(ptr + 8);
			GLenum var_pname = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			uint32_t size_params  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4, checksumSize, 
					"8 + 4 + 4 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_params;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_params(&tmpBuf[0], size_params);
			DEBUG("gles2(%p): glGetVertexAttribfv(%u 0x%08x %p(%u) )", stream,var_index, var_pname, (GLfloat*)(outptr_params.get()), size_params);
			this->glGetVertexAttribfv(var_index, var_pname, (GLfloat*)(outptr_params.get()));
			outptr_params.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(&tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGetVertexAttribfv");
			break;
		}
		case OP_glGetVertexAttribiv: {
			GLuint var_index = Unpack<GLuint,uint32_t>(ptr + 8);
			GLenum var_pname = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			uint32_t size_params  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4, checksumSize, 
					"8 + 4 + 4 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_params;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_params(&tmpBuf[0], size_params);
			DEBUG("gles2(%p): glGetVertexAttribiv(%u 0x%08x %p(%u) )", stream,var_index, var_pname, (GLint*)(outptr_params.get()), size_params);
			this->glGetVertexAttribiv(var_index, var_pname, (GLint*)(outptr_params.get()));
			outptr_params.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(&tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGetVertexAttribiv");
			break;
		}
		case OP_glGetVertexAttribPointerv: {
			GLuint var_index = Unpack<GLuint,uint32_t>(ptr + 8);
			GLenum var_pname = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			uint32_t size_pointer  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			InputBuffer inptr_pointer(ptr + 8 + 4 + 4 + 4, size_pointer);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4 + size_pointer, ptr + 8 + 4 + 4 + 4 + size_pointer, checksumSize, 
					"8 + 4 + 4 + 4 + size_pointer::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glGetVertexAttribPointerv(%u 0x%08x %p(%u) )", stream,var_index, var_pname, (GLvoid**)(inptr_pointer.get()), size_pointer);
			this->glGetVertexAttribPointerv(var_index, var_pname, (GLvoid**)(inptr_pointer.get()));
			SET_LASTCALL("glGetVertexAttribPointerv");
			break;
		}
		case OP_glHint: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLenum var_mode = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize, 
					"8 + 4 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glHint(0x%08x 0x%08x )", stream,var_target, var_mode);
			this->glHint(var_target, var_mode);
			SET_LASTCALL("glHint");
			break;
		}
		case OP_glIsBuffer: {
			GLuint var_buffer = Unpack<GLuint,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"8 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(GLboolean);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			DEBUG("gles2(%p): glIsBuffer(%u )", stream,var_buffer);
			*(GLboolean *)(&tmpBuf[0]) = 			this->glIsBuffer(var_buffer);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(&tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glIsBuffer");
			break;
		}
		case OP_glIsEnabled: {
			GLenum var_cap = Unpack<GLenum,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"8 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(GLboolean);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			DEBUG("gles2(%p): glIsEnabled(0x%08x )", stream,var_cap);
			*(GLboolean *)(&tmpBuf[0]) = 			this->glIsEnabled(var_cap);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(&tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glIsEnabled");
			break;
		}
		case OP_glIsFramebuffer: {
			GLuint var_framebuffer = Unpack<GLuint,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"8 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(GLboolean);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			DEBUG("gles2(%p): glIsFramebuffer(%u )", stream,var_framebuffer);
			*(GLboolean *)(&tmpBuf[0]) = 			this->glIsFramebuffer(var_framebuffer);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(&tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glIsFramebuffer");
			break;
		}
		case OP_glIsProgram: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"8 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(GLboolean);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			DEBUG("gles2(%p): glIsProgram(%u )", stream,var_program);
			*(GLboolean *)(&tmpBuf[0]) = 			this->glIsProgram(var_program);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(&tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glIsProgram");
			break;
		}
		case OP_glIsRenderbuffer: {
			GLuint var_renderbuffer = Unpack<GLuint,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"8 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(GLboolean);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			DEBUG("gles2(%p): glIsRenderbuffer(%u )", stream,var_renderbuffer);
			*(GLboolean *)(&tmpBuf[0]) = 			this->glIsRenderbuffer(var_renderbuffer);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(&tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glIsRenderbuffer");
			break;
		}
		case OP_glIsShader: {
			GLuint var_shader = Unpack<GLuint,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"8 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(GLboolean);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			DEBUG("gles2(%p): glIsShader(%u )", stream,var_shader);
			*(GLboolean *)(&tmpBuf[0]) = 			this->glIsShader(var_shader);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(&tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glIsShader");
			break;
		}
		case OP_glIsTexture: {
			GLuint var_texture = Unpack<GLuint,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"8 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(GLboolean);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			DEBUG("gles2(%p): glIsTexture(%u )", stream,var_texture);
			*(GLboolean *)(&tmpBuf[0]) = 			this->glIsTexture(var_texture);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(&tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glIsTexture");
			break;
		}
		case OP_glLineWidth: {
			GLfloat var_width = Unpack<GLfloat,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"8 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glLineWidth(%f )", stream,var_width);
			this->glLineWidth(var_width);
			SET_LASTCALL("glLineWidth");
			break;
		}
		case OP_glLinkProgram: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"8 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glLinkProgram(%u )", stream,var_program);
			this->glLinkProgram(var_program);
			SET_LASTCALL("glLinkProgram");
	
						m_lock.lock();
						m_programs.insert({var_program, 1});
						m_lock.unlock();
			break;
		}
		case OP_glPixelStorei: {
			GLenum var_pname = Unpack<GLenum,uint32_t>(ptr + 8);
			GLint var_param = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize, 
					"8 + 4 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glPixelStorei(0x%08x %d )", stream,var_pname, var_param);
			this->glPixelStorei(var_pname, var_param);
			SET_LASTCALL("glPixelStorei");
			break;
		}
		case OP_glPolygonOffset: {
			GLfloat var_factor = Unpack<GLfloat,uint32_t>(ptr + 8);
			GLfloat var_units = Unpack<GLfloat,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize, 
					"8 + 4 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glPolygonOffset(%f %f )", stream,var_factor, var_units);
			this->glPolygonOffset(var_factor, var_units);
			SET_LASTCALL("glPolygonOffset");
			break;
		}
		case OP_glReadPixels: {
			GLint var_x = Unpack<GLint,uint32_t>(ptr + 8);
			GLint var_y = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLsizei var_width = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4);
			GLsizei var_height = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4);
			GLenum var_format = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			GLenum var_type = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4);
			uint32_t size_pixels  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4, checksumSize, 
					"8 + 4 + 4 + 4 + 4 + 4 + 4 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_pixels;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_pixels(&tmpBuf[0], size_pixels);
			DEBUG("gles2(%p): glReadPixels(%d %d %d %d 0x%08x 0x%08x %p(%u) )", stream,var_x, var_y, var_width, var_height, var_format, var_type, (GLvoid*)(outptr_pixels.get()), size_pixels);
			this->glReadPixels(var_x, var_y, var_width, var_height, var_format, var_type, (GLvoid*)(outptr_pixels.get()));
			outptr_pixels.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(&tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glReadPixels");
			break;
		}
		case OP_glReleaseShaderCompiler: {
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8, ptr + 8, checksumSize, 
					"8::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glReleaseShaderCompiler()", stream);
			this->glReleaseShaderCompiler();
			SET_LASTCALL("glReleaseShaderCompiler");
			break;
		}
		case OP_glRenderbufferStorage: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLenum var_internalformat = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			GLsizei var_width = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4);
			GLsizei var_height = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4, checksumSize, 
					"8 + 4 + 4 + 4 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glRenderbufferStorage(0x%08x 0x%08x %d %d )", stream,var_target, var_internalformat, var_width, var_height);
			this->glRenderbufferStorage(var_target, var_internalformat, var_width, var_height);
			SET_LASTCALL("glRenderbufferStorage");
			break;
		}
		case OP_glSampleCoverage: {
			GLclampf var_value = Unpack<GLclampf,uint32_t>(ptr + 8);
			GLboolean var_invert = Unpack<GLboolean,uint8_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 1, ptr + 8 + 4 + 1, checksumSize, 
					"8 + 4 + 1::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glSampleCoverage(%f %d )", stream,var_value, var_invert);
			this->glSampleCoverage(var_value, var_invert);
			SET_LASTCALL("glSampleCoverage");
			break;
		}
		case OP_glScissor: {
			GLint var_x = Unpack<GLint,uint32_t>(ptr + 8);
			GLint var_y = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLsizei var_width = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4);
			GLsizei var_height = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4, checksumSize, 
					"8 + 4 + 4 + 4 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glScissor(%d %d %d %d )", stream,var_x, var_y, var_width, var_height);
			this->glScissor(var_x, var_y, var_width, var_height);
			SET_LASTCALL("glScissor");
			break;
		}
		case OP_glShaderBinary: {
			GLsizei var_n = Unpack<GLsizei,uint32_t>(ptr + 8);
			uint32_t size_shaders  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			InputBuffer inptr_shaders(ptr + 8 + 4 + 4, size_shaders);
			GLenum var_binaryformat = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4 + size_shaders);
			uint32_t size_binary  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + size_shaders + 4);
			InputBuffer inptr_binary(ptr + 8 + 4 + 4 + size_shaders + 4 + 4, size_binary);
			GLsizei var_length = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + size_shaders + 4 + 4 + size_binary);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + size_shaders + 4 + 4 + size_binary + 4, ptr + 8 + 4 + 4 + size_shaders + 4 + 4 + size_binary + 4, checksumSize, 
					"8 + 4 + 4 + size_shaders + 4 + 4 + size_binary + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glShaderBinary(%d %p(%u) 0x%08x %p(%u) %d )", stream,var_n, (const GLuint*)(inptr_shaders.get()), size_shaders, var_binaryformat, (const GLvoid*)(inptr_binary.get()), size_binary, var_length);
			this->glShaderBinary(var_n, (const GLuint*)(inptr_shaders.get()), var_binaryformat, (const GLvoid*)(inptr_binary.get()), var_length);
			SET_LASTCALL("glShaderBinary");
			break;
		}
		case OP_glShaderSource: {
			GLuint var_shader = Unpack<GLuint,uint32_t>(ptr + 8);
			GLsizei var_count = Unpack<GLsizei,uint32_t>(ptr + 8 + 4);
			uint32_t size_string  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			InputBuffer inptr_string(ptr + 8 + 4 + 4 + 4, size_string);
			uint32_t size_length  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + size_string);
			InputBuffer inptr_length(ptr + 8 + 4 + 4 + 4 + size_string + 4, size_length);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4 + size_string + 4 + size_length, ptr + 8 + 4 + 4 + 4 + size_string + 4 + size_length, checksumSize, 
					"8 + 4 + 4 + 4 + size_string + 4 + size_length::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glShaderSource(%u %d %p(%u) %p(%u) )", stream,var_shader, var_count, (const GLchar* const*)(inptr_string.get()), size_string, (const GLint*)(inptr_length.get()), size_length);
			this->glShaderSource(var_shader, var_count, (const GLchar* const*)(inptr_string.get()), (const GLint*)(inptr_length.get()));
			SET_LASTCALL("glShaderSource");
			break;
		}
		case OP_glStencilFunc: {
			GLenum var_func = Unpack<GLenum,uint32_t>(ptr + 8);
			GLint var_ref = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLuint var_mask = Unpack<GLuint,uint32_t>(ptr + 8 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4, checksumSize, 
					"8 + 4 + 4 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glStencilFunc(0x%08x %d %u )", stream,var_func, var_ref, var_mask);
			this->glStencilFunc(var_func, var_ref, var_mask);
			SET_LASTCALL("glStencilFunc");
			break;
		}
		case OP_glStencilFuncSeparate: {
			GLenum var_face = Unpack<GLenum,uint32_t>(ptr + 8);
			GLenum var_func = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			GLint var_ref = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4);
			GLuint var_mask = Unpack<GLuint,uint32_t>(ptr + 8 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4, checksumSize, 
					"8 + 4 + 4 + 4 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glStencilFuncSeparate(0x%08x 0x%08x %d %u )", stream,var_face, var_func, var_ref, var_mask);
			this->glStencilFuncSeparate(var_face, var_func, var_ref, var_mask);
			SET_LASTCALL("glStencilFuncSeparate");
			break;
		}
		case OP_glStencilMask: {
			GLuint var_mask = Unpack<GLuint,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"8 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glStencilMask(%u )", stream,var_mask);
			this->glStencilMask(var_mask);
			SET_LASTCALL("glStencilMask");
			break;
		}
		case OP_glStencilMaskSeparate: {
			GLenum var_face = Unpack<GLenum,uint32_t>(ptr + 8);
			GLuint var_mask = Unpack<GLuint,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize, 
					"8 + 4 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glStencilMaskSeparate(0x%08x %u )", stream,var_face, var_mask);
			this->glStencilMaskSeparate(var_face, var_mask);
			SET_LASTCALL("glStencilMaskSeparate");
			break;
		}
		case OP_glStencilOp: {
			GLenum var_fail = Unpack<GLenum,uint32_t>(ptr + 8);
			GLenum var_zfail = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			GLenum var_zpass = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4, checksumSize, 
					"8 + 4 + 4 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glStencilOp(0x%08x 0x%08x 0x%08x )", stream,var_fail, var_zfail, var_zpass);
			this->glStencilOp(var_fail, var_zfail, var_zpass);
			SET_LASTCALL("glStencilOp");
			break;
		}
		case OP_glStencilOpSeparate: {
			GLenum var_face = Unpack<GLenum,uint32_t>(ptr + 8);
			GLenum var_fail = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			GLenum var_zfail = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4);
			GLenum var_zpass = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4, checksumSize, 
					"8 + 4 + 4 + 4 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glStencilOpSeparate(0x%08x 0x%08x 0x%08x 0x%08x )", stream,var_face, var_fail, var_zfail, var_zpass);
			this->glStencilOpSeparate(var_face, var_fail, var_zfail, var_zpass);
			SET_LASTCALL("glStencilOpSeparate");
			break;
		}
		case OP_glTexImage2D: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLint var_level = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLint var_internalformat = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4);
			GLsizei var_width = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4);
			GLsizei var_height = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			GLint var_border = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4);
			GLenum var_format = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4);
			GLenum var_type = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			uint32_t size_pixels  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			InputBuffer inptr_pixels(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4, size_pixels);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + size_pixels, ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + size_pixels, checksumSize, 
					"8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + size_pixels::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glTexImage2D(0x%08x %d %d %d %d %d 0x%08x 0x%08x %p(%u) )", stream,var_target, var_level, var_internalformat, var_width, var_height, var_border, var_format, var_type, (const GLvoid*)(inptr_pixels.get()), size_pixels);
			this->glTexImage2D(var_target, var_level, var_internalformat, var_width, var_height, var_border, var_format, var_type, size_pixels == 0 ? NULL : (const GLvoid*)(inptr_pixels.get()));
			SET_LASTCALL("glTexImage2D");
			break;
		}
		case OP_glTexParameterf: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLenum var_pname = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			GLfloat var_param = Unpack<GLfloat,uint32_t>(ptr + 8 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4, checksumSize, 
					"8 + 4 + 4 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glTexParameterf(0x%08x 0x%08x %f )", stream,var_target, var_pname, var_param);
			this->glTexParameterf(var_target, var_pname, var_param);
			SET_LASTCALL("glTexParameterf");
			break;
		}
		case OP_glTexParameterfv: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLenum var_pname = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			uint32_t size_params  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			InputBuffer inptr_params(ptr + 8 + 4 + 4 + 4, size_params);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4 + size_params, ptr + 8 + 4 + 4 + 4 + size_params, checksumSize, 
					"8 + 4 + 4 + 4 + size_params::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glTexParameterfv(0x%08x 0x%08x %p(%u) )", stream,var_target, var_pname, (const GLfloat*)(inptr_params.get()), size_params);
			this->glTexParameterfv(var_target, var_pname, (const GLfloat*)(inptr_params.get()));
			SET_LASTCALL("glTexParameterfv");
			break;
		}
		case OP_glTexParameteri: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLenum var_pname = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			GLint var_param = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4, checksumSize, 
					"8 + 4 + 4 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glTexParameteri(0x%08x 0x%08x %d )", stream,var_target, var_pname, var_param);
			this->glTexParameteri(var_target, var_pname, var_param);
			SET_LASTCALL("glTexParameteri");
			break;
		}
		case OP_glTexParameteriv: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLenum var_pname = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			uint32_t size_params  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			InputBuffer inptr_params(ptr + 8 + 4 + 4 + 4, size_params);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4 + size_params, ptr + 8 + 4 + 4 + 4 + size_params, checksumSize, 
					"8 + 4 + 4 + 4 + size_params::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glTexParameteriv(0x%08x 0x%08x %p(%u) )", stream,var_target, var_pname, (const GLint*)(inptr_params.get()), size_params);
			this->glTexParameteriv(var_target, var_pname, (const GLint*)(inptr_params.get()));
			SET_LASTCALL("glTexParameteriv");
			break;
		}
		case OP_glTexSubImage2D: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLint var_level = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLint var_xoffset = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4);
			GLint var_yoffset = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4);
			GLsizei var_width = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			GLsizei var_height = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4);
			GLenum var_format = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4);
			GLenum var_type = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			uint32_t size_pixels  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			InputBuffer inptr_pixels(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4, size_pixels);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + size_pixels, ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + size_pixels, checksumSize, 
					"8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + size_pixels::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glTexSubImage2D(0x%08x %d %d %d %d %d 0x%08x 0x%08x %p(%u) )", stream,var_target, var_level, var_xoffset, var_yoffset, var_width, var_height, var_format, var_type, (const GLvoid*)(inptr_pixels.get()), size_pixels);
			this->glTexSubImage2D(var_target, var_level, var_xoffset, var_yoffset, var_width, var_height, var_format, var_type, size_pixels == 0 ? NULL : (const GLvoid*)(inptr_pixels.get()));
			SET_LASTCALL("glTexSubImage2D");
			break;
		}
		case OP_glUniform1f: {
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8);
			GLfloat var_x = Unpack<GLfloat,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize, 
					"8 + 4 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glUniform1f(%d %f )", stream,var_location, var_x);
			this->glUniform1f(var_location, var_x);
			SET_LASTCALL("glUniform1f");
			break;
		}
		case OP_glUniform1fv: {
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8);
			GLsizei var_count = Unpack<GLsizei,uint32_t>(ptr + 8 + 4);
			uint32_t size_v  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			InputBuffer inptr_v(ptr + 8 + 4 + 4 + 4, size_v);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4 + size_v, ptr + 8 + 4 + 4 + 4 + size_v, checksumSize, 
					"8 + 4 + 4 + 4 + size_v::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glUniform1fv(%d %d %p(%u) )", stream,var_location, var_count, (const GLfloat*)(inptr_v.get()), size_v);
			this->glUniform1fv(var_location, var_count, (const GLfloat*)(inptr_v.get()));
			SET_LASTCALL("glUniform1fv");
			break;
		}
		case OP_glUniform1i: {
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8);
			GLint var_x = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize, 
					"8 + 4 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glUniform1i(%d %d )", stream,var_location, var_x);
			this->glUniform1i(var_location, var_x);
			SET_LASTCALL("glUniform1i");
			break;
		}
		case OP_glUniform1iv: {
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8);
			GLsizei var_count = Unpack<GLsizei,uint32_t>(ptr + 8 + 4);
			uint32_t size_v  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			InputBuffer inptr_v(ptr + 8 + 4 + 4 + 4, size_v);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4 + size_v, ptr + 8 + 4 + 4 + 4 + size_v, checksumSize, 
					"8 + 4 + 4 + 4 + size_v::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glUniform1iv(%d %d %p(%u) )", stream,var_location, var_count, (const GLint*)(inptr_v.get()), size_v);
			this->glUniform1iv(var_location, var_count, (const GLint*)(inptr_v.get()));
			SET_LASTCALL("glUniform1iv");
			break;
		}
		case OP_glUniform2f: {
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8);
			GLfloat var_x = Unpack<GLfloat,uint32_t>(ptr + 8 + 4);
			GLfloat var_y = Unpack<GLfloat,uint32_t>(ptr + 8 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4, checksumSize, 
					"8 + 4 + 4 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glUniform2f(%d %f %f )", stream,var_location, var_x, var_y);
			this->glUniform2f(var_location, var_x, var_y);
			SET_LASTCALL("glUniform2f");
			break;
		}
		case OP_glUniform2fv: {
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8);
			GLsizei var_count = Unpack<GLsizei,uint32_t>(ptr + 8 + 4);
			uint32_t size_v  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			InputBuffer inptr_v(ptr + 8 + 4 + 4 + 4, size_v);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4 + size_v, ptr + 8 + 4 + 4 + 4 + size_v, checksumSize, 
					"8 + 4 + 4 + 4 + size_v::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glUniform2fv(%d %d %p(%u) )", stream,var_location, var_count, (const GLfloat*)(inptr_v.get()), size_v);
			this->glUniform2fv(var_location, var_count, (const GLfloat*)(inptr_v.get()));
			SET_LASTCALL("glUniform2fv");
			break;
		}
		case OP_glUniform2i: {
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8);
			GLint var_x = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLint var_y = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4, checksumSize, 
					"8 + 4 + 4 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glUniform2i(%d %d %d )", stream,var_location, var_x, var_y);
			this->glUniform2i(var_location, var_x, var_y);
			SET_LASTCALL("glUniform2i");
			break;
		}
		case OP_glUniform2iv: {
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8);
			GLsizei var_count = Unpack<GLsizei,uint32_t>(ptr + 8 + 4);
			uint32_t size_v  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			InputBuffer inptr_v(ptr + 8 + 4 + 4 + 4, size_v);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4 + size_v, ptr + 8 + 4 + 4 + 4 + size_v, checksumSize, 
					"8 + 4 + 4 + 4 + size_v::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glUniform2iv(%d %d %p(%u) )", stream,var_location, var_count, (const GLint*)(inptr_v.get()), size_v);
			this->glUniform2iv(var_location, var_count, (const GLint*)(inptr_v.get()));
			SET_LASTCALL("glUniform2iv");
			break;
		}
		case OP_glUniform3f: {
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8);
			GLfloat var_x = Unpack<GLfloat,uint32_t>(ptr + 8 + 4);
			GLfloat var_y = Unpack<GLfloat,uint32_t>(ptr + 8 + 4 + 4);
			GLfloat var_z = Unpack<GLfloat,uint32_t>(ptr + 8 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4, checksumSize, 
					"8 + 4 + 4 + 4 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glUniform3f(%d %f %f %f )", stream,var_location, var_x, var_y, var_z);
			this->glUniform3f(var_location, var_x, var_y, var_z);
			SET_LASTCALL("glUniform3f");
			break;
		}
		case OP_glUniform3fv: {
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8);
			GLsizei var_count = Unpack<GLsizei,uint32_t>(ptr + 8 + 4);
			uint32_t size_v  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			InputBuffer inptr_v(ptr + 8 + 4 + 4 + 4, size_v);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4 + size_v, ptr + 8 + 4 + 4 + 4 + size_v, checksumSize, 
					"8 + 4 + 4 + 4 + size_v::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glUniform3fv(%d %d %p(%u) )", stream,var_location, var_count, (const GLfloat*)(inptr_v.get()), size_v);
			this->glUniform3fv(var_location, var_count, (const GLfloat*)(inptr_v.get()));
			SET_LASTCALL("glUniform3fv");
			break;
		}
		case OP_glUniform3i: {
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8);
			GLint var_x = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLint var_y = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4);
			GLint var_z = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4, checksumSize, 
					"8 + 4 + 4 + 4 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glUniform3i(%d %d %d %d )", stream,var_location, var_x, var_y, var_z);
			this->glUniform3i(var_location, var_x, var_y, var_z);
			SET_LASTCALL("glUniform3i");
			break;
		}
		case OP_glUniform3iv: {
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8);
			GLsizei var_count = Unpack<GLsizei,uint32_t>(ptr + 8 + 4);
			uint32_t size_v  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			InputBuffer inptr_v(ptr + 8 + 4 + 4 + 4, size_v);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4 + size_v, ptr + 8 + 4 + 4 + 4 + size_v, checksumSize, 
					"8 + 4 + 4 + 4 + size_v::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glUniform3iv(%d %d %p(%u) )", stream,var_location, var_count, (const GLint*)(inptr_v.get()), size_v);
			this->glUniform3iv(var_location, var_count, (const GLint*)(inptr_v.get()));
			SET_LASTCALL("glUniform3iv");
			break;
		}
		case OP_glUniform4f: {
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8);
			GLfloat var_x = Unpack<GLfloat,uint32_t>(ptr + 8 + 4);
			GLfloat var_y = Unpack<GLfloat,uint32_t>(ptr + 8 + 4 + 4);
			GLfloat var_z = Unpack<GLfloat,uint32_t>(ptr + 8 + 4 + 4 + 4);
			GLfloat var_w = Unpack<GLfloat,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4 + 4, checksumSize, 
					"8 + 4 + 4 + 4 + 4 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glUniform4f(%d %f %f %f %f )", stream,var_location, var_x, var_y, var_z, var_w);
			this->glUniform4f(var_location, var_x, var_y, var_z, var_w);
			SET_LASTCALL("glUniform4f");
			break;
		}
		case OP_glUniform4fv: {
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8);
			GLsizei var_count = Unpack<GLsizei,uint32_t>(ptr + 8 + 4);
			uint32_t size_v  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			InputBuffer inptr_v(ptr + 8 + 4 + 4 + 4, size_v);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4 + size_v, ptr + 8 + 4 + 4 + 4 + size_v, checksumSize, 
					"8 + 4 + 4 + 4 + size_v::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glUniform4fv(%d %d %p(%u) )", stream,var_location, var_count, (const GLfloat*)(inptr_v.get()), size_v);
			this->glUniform4fv(var_location, var_count, (const GLfloat*)(inptr_v.get()));
			SET_LASTCALL("glUniform4fv");
			break;
		}
		case OP_glUniform4i: {
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8);
			GLint var_x = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLint var_y = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4);
			GLint var_z = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4);
			GLint var_w = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4 + 4, checksumSize, 
					"8 + 4 + 4 + 4 + 4 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glUniform4i(%d %d %d %d %d )", stream,var_location, var_x, var_y, var_z, var_w);
			this->glUniform4i(var_location, var_x, var_y, var_z, var_w);
			SET_LASTCALL("glUniform4i");
			break;
		}
		case OP_glUniform4iv: {
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8);
			GLsizei var_count = Unpack<GLsizei,uint32_t>(ptr + 8 + 4);
			uint32_t size_v  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			InputBuffer inptr_v(ptr + 8 + 4 + 4 + 4, size_v);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4 + size_v, ptr + 8 + 4 + 4 + 4 + size_v, checksumSize, 
					"8 + 4 + 4 + 4 + size_v::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glUniform4iv(%d %d %p(%u) )", stream,var_location, var_count, (const GLint*)(inptr_v.get()), size_v);
			this->glUniform4iv(var_location, var_count, (const GLint*)(inptr_v.get()));
			SET_LASTCALL("glUniform4iv");
			break;
		}
		case OP_glUniformMatrix2fv: {
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8);
			GLsizei var_count = Unpack<GLsizei,uint32_t>(ptr + 8 + 4);
			GLboolean var_transpose = Unpack<GLboolean,uint8_t>(ptr + 8 + 4 + 4);
			uint32_t size_value  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 1);
			InputBuffer inptr_value(ptr + 8 + 4 + 4 + 1 + 4, size_value);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 1 + 4 + size_value, ptr + 8 + 4 + 4 + 1 + 4 + size_value, checksumSize, 
					"8 + 4 + 4 + 1 + 4 + size_value::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glUniformMatrix2fv(%d %d %d %p(%u) )", stream,var_location, var_count, var_transpose, (const GLfloat*)(inptr_value.get()), size_value);
			this->glUniformMatrix2fv(var_location, var_count, var_transpose, (const GLfloat*)(inptr_value.get()));
			SET_LASTCALL("glUniformMatrix2fv");
			break;
		}
		case OP_glUniformMatrix3fv: {
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8);
			GLsizei var_count = Unpack<GLsizei,uint32_t>(ptr + 8 + 4);
			GLboolean var_transpose = Unpack<GLboolean,uint8_t>(ptr + 8 + 4 + 4);
			uint32_t size_value  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 1);
			InputBuffer inptr_value(ptr + 8 + 4 + 4 + 1 + 4, size_value);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 1 + 4 + size_value, ptr + 8 + 4 + 4 + 1 + 4 + size_value, checksumSize, 
					"8 + 4 + 4 + 1 + 4 + size_value::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glUniformMatrix3fv(%d %d %d %p(%u) )", stream,var_location, var_count, var_transpose, (const GLfloat*)(inptr_value.get()), size_value);
			this->glUniformMatrix3fv(var_location, var_count, var_transpose, (const GLfloat*)(inptr_value.get()));
			SET_LASTCALL("glUniformMatrix3fv");
			break;
		}
		case OP_glUniformMatrix4fv: {
			GLint var_location = Unpack<GLint,uint32_t>(ptr + 8);
			GLsizei var_count = Unpack<GLsizei,uint32_t>(ptr + 8 + 4);
			GLboolean var_transpose = Unpack<GLboolean,uint8_t>(ptr + 8 + 4 + 4);
			uint32_t size_value  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 1);
			InputBuffer inptr_value(ptr + 8 + 4 + 4 + 1 + 4, size_value);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 1 + 4 + size_value, ptr + 8 + 4 + 4 + 1 + 4 + size_value, checksumSize, 
					"8 + 4 + 4 + 1 + 4 + size_value::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glUniformMatrix4fv(%d %d %d %p(%u) )", stream,var_location, var_count, var_transpose, (const GLfloat*)(inptr_value.get()), size_value);
			this->glUniformMatrix4fv(var_location, var_count, var_transpose, (const GLfloat*)(inptr_value.get()));
			SET_LASTCALL("glUniformMatrix4fv");
			break;
		}
		case OP_glUseProgram: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"8 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glUseProgram(%u )", stream,var_program);
			this->glUseProgram(var_program);
			SET_LASTCALL("glUseProgram");
			break;
		}
		case OP_glValidateProgram: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"8 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glValidateProgram(%u )", stream,var_program);
			this->glValidateProgram(var_program);
			SET_LASTCALL("glValidateProgram");
			break;
		}
		case OP_glVertexAttrib1f: {
			GLuint var_indx = Unpack<GLuint,uint32_t>(ptr + 8);
			GLfloat var_x = Unpack<GLfloat,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize, 
					"8 + 4 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glVertexAttrib1f(%u %f )", stream,var_indx, var_x);
			this->glVertexAttrib1f(var_indx, var_x);
			SET_LASTCALL("glVertexAttrib1f");
			break;
		}
		case OP_glVertexAttrib1fv: {
			GLuint var_indx = Unpack<GLuint,uint32_t>(ptr + 8);
			uint32_t size_values  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			InputBuffer inptr_values(ptr + 8 + 4 + 4, size_values);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + size_values, ptr + 8 + 4 + 4 + size_values, checksumSize, 
					"8 + 4 + 4 + size_values::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glVertexAttrib1fv(%u %p(%u) )", stream,var_indx, (const GLfloat*)(inptr_values.get()), size_values);
			this->glVertexAttrib1fv(var_indx, (const GLfloat*)(inptr_values.get()));
			SET_LASTCALL("glVertexAttrib1fv");
			break;
		}
		case OP_glVertexAttrib2f: {
			GLuint var_indx = Unpack<GLuint,uint32_t>(ptr + 8);
			GLfloat var_x = Unpack<GLfloat,uint32_t>(ptr + 8 + 4);
			GLfloat var_y = Unpack<GLfloat,uint32_t>(ptr + 8 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4, checksumSize, 
					"8 + 4 + 4 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glVertexAttrib2f(%u %f %f )", stream,var_indx, var_x, var_y);
			this->glVertexAttrib2f(var_indx, var_x, var_y);
			SET_LASTCALL("glVertexAttrib2f");
			break;
		}
		case OP_glVertexAttrib2fv: {
			GLuint var_indx = Unpack<GLuint,uint32_t>(ptr + 8);
			uint32_t size_values  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			InputBuffer inptr_values(ptr + 8 + 4 + 4, size_values);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + size_values, ptr + 8 + 4 + 4 + size_values, checksumSize, 
					"8 + 4 + 4 + size_values::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glVertexAttrib2fv(%u %p(%u) )", stream,var_indx, (const GLfloat*)(inptr_values.get()), size_values);
			this->glVertexAttrib2fv(var_indx, (const GLfloat*)(inptr_values.get()));
			SET_LASTCALL("glVertexAttrib2fv");
			break;
		}
		case OP_glVertexAttrib3f: {
			GLuint var_indx = Unpack<GLuint,uint32_t>(ptr + 8);
			GLfloat var_x = Unpack<GLfloat,uint32_t>(ptr + 8 + 4);
			GLfloat var_y = Unpack<GLfloat,uint32_t>(ptr + 8 + 4 + 4);
			GLfloat var_z = Unpack<GLfloat,uint32_t>(ptr + 8 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4, checksumSize, 
					"8 + 4 + 4 + 4 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glVertexAttrib3f(%u %f %f %f )", stream,var_indx, var_x, var_y, var_z);
			this->glVertexAttrib3f(var_indx, var_x, var_y, var_z);
			SET_LASTCALL("glVertexAttrib3f");
			break;
		}
		case OP_glVertexAttrib3fv: {
			GLuint var_indx = Unpack<GLuint,uint32_t>(ptr + 8);
			uint32_t size_values  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			InputBuffer inptr_values(ptr + 8 + 4 + 4, size_values);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + size_values, ptr + 8 + 4 + 4 + size_values, checksumSize, 
					"8 + 4 + 4 + size_values::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glVertexAttrib3fv(%u %p(%u) )", stream,var_indx, (const GLfloat*)(inptr_values.get()), size_values);
			this->glVertexAttrib3fv(var_indx, (const GLfloat*)(inptr_values.get()));
			SET_LASTCALL("glVertexAttrib3fv");
			break;
		}
		case OP_glVertexAttrib4f: {
			GLuint var_indx = Unpack<GLuint,uint32_t>(ptr + 8);
			GLfloat var_x = Unpack<GLfloat,uint32_t>(ptr + 8 + 4);
			GLfloat var_y = Unpack<GLfloat,uint32_t>(ptr + 8 + 4 + 4);
			GLfloat var_z = Unpack<GLfloat,uint32_t>(ptr + 8 + 4 + 4 + 4);
			GLfloat var_w = Unpack<GLfloat,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4 + 4, checksumSize, 
					"8 + 4 + 4 + 4 + 4 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glVertexAttrib4f(%u %f %f %f %f )", stream,var_indx, var_x, var_y, var_z, var_w);
			this->glVertexAttrib4f(var_indx, var_x, var_y, var_z, var_w);
			SET_LASTCALL("glVertexAttrib4f");
			break;
		}
		case OP_glVertexAttrib4fv: {
			GLuint var_indx = Unpack<GLuint,uint32_t>(ptr + 8);
			uint32_t size_values  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			InputBuffer inptr_values(ptr + 8 + 4 + 4, size_values);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + size_values, ptr + 8 + 4 + 4 + size_values, checksumSize, 
					"8 + 4 + 4 + size_values::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glVertexAttrib4fv(%u %p(%u) )", stream,var_indx, (const GLfloat*)(inptr_values.get()), size_values);
			this->glVertexAttrib4fv(var_indx, (const GLfloat*)(inptr_values.get()));
			SET_LASTCALL("glVertexAttrib4fv");
			break;
		}
		case OP_glVertexAttribPointer: {
			GLuint var_indx = Unpack<GLuint,uint32_t>(ptr + 8);
			GLint var_size = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLenum var_type = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4);
			GLboolean var_normalized = Unpack<GLboolean,uint8_t>(ptr + 8 + 4 + 4 + 4);
			GLsizei var_stride = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 1);
			uint32_t size_ptr  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 1 + 4);
			InputBuffer inptr_ptr(ptr + 8 + 4 + 4 + 4 + 1 + 4 + 4, size_ptr);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4 + 1 + 4 + 4 + size_ptr, ptr + 8 + 4 + 4 + 4 + 1 + 4 + 4 + size_ptr, checksumSize, 
					"8 + 4 + 4 + 4 + 1 + 4 + 4 + size_ptr::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glVertexAttribPointer(%u %d 0x%08x %d %d %p(%u) )", stream,var_indx, var_size, var_type, var_normalized, var_stride, (const GLvoid*)(inptr_ptr.get()), size_ptr);
			this->glVertexAttribPointer(var_indx, var_size, var_type, var_normalized, var_stride, (const GLvoid*)(inptr_ptr.get()));
			SET_LASTCALL("glVertexAttribPointer");
			break;
		}
		case OP_glViewport: {
			GLint var_x = Unpack<GLint,uint32_t>(ptr + 8);
			GLint var_y = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLsizei var_width = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4);
			GLsizei var_height = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4, checksumSize, 
					"8 + 4 + 4 + 4 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glViewport(%d %d %d %d )", stream,var_x, var_y, var_width, var_height);
			this->glViewport(var_x, var_y, var_width, var_height);
			SET_LASTCALL("glViewport");
			break;
		}
		case OP_glEGLImageTargetTexture2DOES: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLeglImageOES var_image = Unpack<GLeglImageOES,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize, 
					"8 + 4 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glEGLImageTargetTexture2DOES(0x%08x %p )", stream,var_target, var_image);
			this->glEGLImageTargetTexture2DOES(var_target, var_image);
			SET_LASTCALL("glEGLImageTargetTexture2DOES");
			break;
		}
		case OP_glEGLImageTargetRenderbufferStorageOES: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLeglImageOES var_image = Unpack<GLeglImageOES,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize, 
					"8 + 4 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glEGLImageTargetRenderbufferStorageOES(0x%08x %p )", stream,var_target, var_image);
			this->glEGLImageTargetRenderbufferStorageOES(var_target, var_image);
			SET_LASTCALL("glEGLImageTargetRenderbufferStorageOES");
			break;
		}
		case OP_glGetProgramBinaryOES: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			GLsizei var_bufSize = Unpack<GLsizei,uint32_t>(ptr + 8 + 4);
			uint32_t size_length  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			InputBuffer inptr_length(ptr + 8 + 4 + 4 + 4, size_length);
			uint32_t size_binaryFormat  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + size_length);
			InputBuffer inptr_binaryFormat(ptr + 8 + 4 + 4 + 4 + size_length + 4, size_binaryFormat);
			uint32_t size_binary  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + size_length + 4 + size_binaryFormat);
			InputBuffer inptr_binary(ptr + 8 + 4 + 4 + 4 + size_length + 4 + size_binaryFormat + 4, size_binary);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4 + size_length + 4 + size_binaryFormat + 4 + size_binary, ptr + 8 + 4 + 4 + 4 + size_length + 4 + size_binaryFormat + 4 + size_binary, checksumSize, 
					"8 + 4 + 4 + 4 + size_length + 4 + size_binaryFormat + 4 + size_binary::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glGetProgramBinaryOES(%u %d %p(%u) %p(%u) %p(%u) )", stream,var_program, var_bufSize, (GLsizei*)(inptr_length.get()), size_length, (GLenum*)(inptr_binaryFormat.get()), size_binaryFormat, (GLvoid*)(inptr_binary.get()), size_binary);
			this->glGetProgramBinaryOES(var_program, var_bufSize, (GLsizei*)(inptr_length.get()), (GLenum*)(inptr_binaryFormat.get()), (GLvoid*)(inptr_binary.get()));
			SET_LASTCALL("glGetProgramBinaryOES");
			break;
		}
		case OP_glProgramBinaryOES: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			GLenum var_binaryFormat = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			uint32_t size_binary  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			InputBuffer inptr_binary(ptr + 8 + 4 + 4 + 4, size_binary);
			GLint var_length = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4 + size_binary);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4 + size_binary + 4, ptr + 8 + 4 + 4 + 4 + size_binary + 4, checksumSize, 
					"8 + 4 + 4 + 4 + size_binary + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glProgramBinaryOES(%u 0x%08x %p(%u) %d )", stream,var_program, var_binaryFormat, (const GLvoid*)(inptr_binary.get()), size_binary, var_length);
			this->glProgramBinaryOES(var_program, var_binaryFormat, (const GLvoid*)(inptr_binary.get()), var_length);
			SET_LASTCALL("glProgramBinaryOES");
			break;
		}
		case OP_glMapBufferOES: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLenum var_access = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize, 
					"8 + 4 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glMapBufferOES(0x%08x 0x%08x )", stream,var_target, var_access);
			this->glMapBufferOES(var_target, var_access);
			SET_LASTCALL("glMapBufferOES");
			break;
		}
		case OP_glUnmapBufferOES: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"8 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(GLboolean);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			DEBUG("gles2(%p): glUnmapBufferOES(0x%08x )", stream,var_target);
			*(GLboolean *)(&tmpBuf[0]) = 			this->glUnmapBufferOES(var_target);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(&tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glUnmapBufferOES");
			break;
		}
		case OP_glTexImage3DOES: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLint var_level = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLenum var_internalformat = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4);
			GLsizei var_width = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4);
			GLsizei var_height = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			GLsizei var_depth = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4);
			GLint var_border = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4);
			GLenum var_format = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			GLenum var_type = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			uint32_t size_pixels  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			InputBuffer inptr_pixels(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4, size_pixels);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + size_pixels, ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + size_pixels, checksumSize, 
					"8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + size_pixels::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glTexImage3DOES(0x%08x %d 0x%08x %d %d %d %d 0x%08x 0x%08x %p(%u) )", stream,var_target, var_level, var_internalformat, var_width, var_height, var_depth, var_border, var_format, var_type, (const GLvoid*)(inptr_pixels.get()), size_pixels);
			this->glTexImage3DOES(var_target, var_level, var_internalformat, var_width, var_height, var_depth, var_border, var_format, var_type, size_pixels == 0 ? NULL : (const GLvoid*)(inptr_pixels.get()));
			SET_LASTCALL("glTexImage3DOES");
			break;
		}
		case OP_glTexSubImage3DOES: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLint var_level = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLint var_xoffset = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4);
			GLint var_yoffset = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4);
			GLint var_zoffset = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			GLsizei var_width = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4);
			GLsizei var_height = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4);
			GLsizei var_depth = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			GLenum var_format = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			GLenum var_type = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			uint32_t size_pixels  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			InputBuffer inptr_pixels(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4, size_pixels);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + size_pixels, ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + size_pixels, checksumSize, 
					"8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + size_pixels::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glTexSubImage3DOES(0x%08x %d %d %d %d %d %d %d 0x%08x 0x%08x %p(%u) )", stream,var_target, var_level, var_xoffset, var_yoffset, var_zoffset, var_width, var_height, var_depth, var_format, var_type, (const GLvoid*)(inptr_pixels.get()), size_pixels);
			this->glTexSubImage3DOES(var_target, var_level, var_xoffset, var_yoffset, var_zoffset, var_width, var_height, var_depth, var_format, var_type, size_pixels == 0 ? NULL : (const GLvoid*)(inptr_pixels.get()));
			SET_LASTCALL("glTexSubImage3DOES");
			break;
		}
		case OP_glCopyTexSubImage3DOES: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLint var_level = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLint var_xoffset = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4);
			GLint var_yoffset = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4);
			GLint var_zoffset = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			GLint var_x = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4);
			GLint var_y = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4);
			GLsizei var_width = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			GLsizei var_height = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4, checksumSize, 
					"8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glCopyTexSubImage3DOES(0x%08x %d %d %d %d %d %d %d %d )", stream,var_target, var_level, var_xoffset, var_yoffset, var_zoffset, var_x, var_y, var_width, var_height);
			this->glCopyTexSubImage3DOES(var_target, var_level, var_xoffset, var_yoffset, var_zoffset, var_x, var_y, var_width, var_height);
			SET_LASTCALL("glCopyTexSubImage3DOES");
			break;
		}
		case OP_glCompressedTexImage3DOES: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLint var_level = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLenum var_internalformat = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4);
			GLsizei var_width = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4);
			GLsizei var_height = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			GLsizei var_depth = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4);
			GLint var_border = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4);
			GLsizei var_imageSize = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			uint32_t size_data  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			InputBuffer inptr_data(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4, size_data);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + size_data, ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + size_data, checksumSize, 
					"8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + size_data::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glCompressedTexImage3DOES(0x%08x %d 0x%08x %d %d %d %d %d %p(%u) )", stream,var_target, var_level, var_internalformat, var_width, var_height, var_depth, var_border, var_imageSize, (const GLvoid*)(inptr_data.get()), size_data);
			this->glCompressedTexImage3DOES(var_target, var_level, var_internalformat, var_width, var_height, var_depth, var_border, var_imageSize, size_data == 0 ? NULL : (const GLvoid*)(inptr_data.get()));
			SET_LASTCALL("glCompressedTexImage3DOES");
			break;
		}
		case OP_glCompressedTexSubImage3DOES: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLint var_level = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLint var_xoffset = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4);
			GLint var_yoffset = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4);
			GLint var_zoffset = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			GLsizei var_width = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4);
			GLsizei var_height = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4);
			GLsizei var_depth = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			GLenum var_format = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			GLsizei var_imageSize = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			uint32_t size_data  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			InputBuffer inptr_data(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4, size_data);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + size_data, ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + size_data, checksumSize, 
					"8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + size_data::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glCompressedTexSubImage3DOES(0x%08x %d %d %d %d %d %d %d 0x%08x %d %p(%u) )", stream,var_target, var_level, var_xoffset, var_yoffset, var_zoffset, var_width, var_height, var_depth, var_format, var_imageSize, (const GLvoid*)(inptr_data.get()), size_data);
			this->glCompressedTexSubImage3DOES(var_target, var_level, var_xoffset, var_yoffset, var_zoffset, var_width, var_height, var_depth, var_format, var_imageSize, size_data == 0 ? NULL : (const GLvoid*)(inptr_data.get()));
			SET_LASTCALL("glCompressedTexSubImage3DOES");
			break;
		}
		case OP_glFramebufferTexture3DOES: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLenum var_attachment = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			GLenum var_textarget = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4);
			GLuint var_texture = Unpack<GLuint,uint32_t>(ptr + 8 + 4 + 4 + 4);
			GLint var_level = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			GLint var_zoffset = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4, checksumSize, 
					"8 + 4 + 4 + 4 + 4 + 4 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glFramebufferTexture3DOES(0x%08x 0x%08x 0x%08x %u %d %d )", stream,var_target, var_attachment, var_textarget, var_texture, var_level, var_zoffset);
			this->glFramebufferTexture3DOES(var_target, var_attachment, var_textarget, var_texture, var_level, var_zoffset);
			SET_LASTCALL("glFramebufferTexture3DOES");
			break;
		}
		case OP_glBindVertexArrayOES: {
			GLuint var_array = Unpack<GLuint,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"8 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glBindVertexArrayOES(%u )", stream,var_array);
			this->glBindVertexArrayOES(var_array);
			SET_LASTCALL("glBindVertexArrayOES");
			break;
		}
		case OP_glDeleteVertexArraysOES: {
			GLsizei var_n = Unpack<GLsizei,uint32_t>(ptr + 8);
			uint32_t size_arrays  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			InputBuffer inptr_arrays(ptr + 8 + 4 + 4, size_arrays);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + size_arrays, ptr + 8 + 4 + 4 + size_arrays, checksumSize, 
					"8 + 4 + 4 + size_arrays::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glDeleteVertexArraysOES(%d %p(%u) )", stream,var_n, (const GLuint*)(inptr_arrays.get()), size_arrays);
			this->glDeleteVertexArraysOES(var_n, (const GLuint*)(inptr_arrays.get()));
			SET_LASTCALL("glDeleteVertexArraysOES");
			break;
		}
		case OP_glGenVertexArraysOES: {
			GLsizei var_n = Unpack<GLsizei,uint32_t>(ptr + 8);
			uint32_t size_arrays  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize, 
					"8 + 4 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_arrays;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_arrays(&tmpBuf[0], size_arrays);
			DEBUG("gles2(%p): glGenVertexArraysOES(%d %p(%u) )", stream,var_n, (GLuint*)(outptr_arrays.get()), size_arrays);
			this->glGenVertexArraysOES(var_n, (GLuint*)(outptr_arrays.get()));
			outptr_arrays.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(&tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGenVertexArraysOES");
			break;
		}
		case OP_glIsVertexArrayOES: {
			GLuint var_array = Unpack<GLuint,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"8 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(GLboolean);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			DEBUG("gles2(%p): glIsVertexArrayOES(%u )", stream,var_array);
			*(GLboolean *)(&tmpBuf[0]) = 			this->glIsVertexArrayOES(var_array);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(&tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glIsVertexArrayOES");
			break;
		}
		case OP_glDiscardFramebufferEXT: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLsizei var_numAttachments = Unpack<GLsizei,uint32_t>(ptr + 8 + 4);
			uint32_t size_attachments  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			InputBuffer inptr_attachments(ptr + 8 + 4 + 4 + 4, size_attachments);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4 + size_attachments, ptr + 8 + 4 + 4 + 4 + size_attachments, checksumSize, 
					"8 + 4 + 4 + 4 + size_attachments::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glDiscardFramebufferEXT(0x%08x %d %p(%u) )", stream,var_target, var_numAttachments, (const GLenum*)(inptr_attachments.get()), size_attachments);
			this->glDiscardFramebufferEXT(var_target, var_numAttachments, (const GLenum*)(inptr_attachments.get()));
			SET_LASTCALL("glDiscardFramebufferEXT");
			break;
		}
		case OP_glMultiDrawArraysEXT: {
			GLenum var_mode = Unpack<GLenum,uint32_t>(ptr + 8);
			uint32_t size_first  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			InputBuffer inptr_first(ptr + 8 + 4 + 4, size_first);
			uint32_t size_count  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + size_first);
			InputBuffer inptr_count(ptr + 8 + 4 + 4 + size_first + 4, size_count);
			GLsizei var_primcount = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + size_first + 4 + size_count);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + size_first + 4 + size_count + 4, ptr + 8 + 4 + 4 + size_first + 4 + size_count + 4, checksumSize, 
					"8 + 4 + 4 + size_first + 4 + size_count + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glMultiDrawArraysEXT(0x%08x %p(%u) %p(%u) %d )", stream,var_mode, (const GLint*)(inptr_first.get()), size_first, (const GLsizei*)(inptr_count.get()), size_count, var_primcount);
			this->glMultiDrawArraysEXT(var_mode, (const GLint*)(inptr_first.get()), (const GLsizei*)(inptr_count.get()), var_primcount);
			SET_LASTCALL("glMultiDrawArraysEXT");
			break;
		}
		case OP_glMultiDrawElementsEXT: {
			GLenum var_mode = Unpack<GLenum,uint32_t>(ptr + 8);
			uint32_t size_count  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			InputBuffer inptr_count(ptr + 8 + 4 + 4, size_count);
			GLenum var_type = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4 + size_count);
			uint32_t size_indices  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + size_count + 4);
			InputBuffer inptr_indices(ptr + 8 + 4 + 4 + size_count + 4 + 4, size_indices);
			GLsizei var_primcount = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + size_count + 4 + 4 + size_indices);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + size_count + 4 + 4 + size_indices + 4, ptr + 8 + 4 + 4 + size_count + 4 + 4 + size_indices + 4, checksumSize, 
					"8 + 4 + 4 + size_count + 4 + 4 + size_indices + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glMultiDrawElementsEXT(0x%08x %p(%u) 0x%08x %p(%u) %d )", stream,var_mode, (const GLsizei*)(inptr_count.get()), size_count, var_type, (const GLvoid* const*)(inptr_indices.get()), size_indices, var_primcount);
			this->glMultiDrawElementsEXT(var_mode, (const GLsizei*)(inptr_count.get()), var_type, (const GLvoid* const*)(inptr_indices.get()), var_primcount);
			SET_LASTCALL("glMultiDrawElementsEXT");
			break;
		}
		case OP_glGetPerfMonitorGroupsAMD: {
			uint32_t size_numGroups  = Unpack<uint32_t,uint32_t>(ptr + 8);
			InputBuffer inptr_numGroups(ptr + 8 + 4, size_numGroups);
			GLsizei var_groupsSize = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + size_numGroups);
			uint32_t size_groups  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + size_numGroups + 4);
			InputBuffer inptr_groups(ptr + 8 + 4 + size_numGroups + 4 + 4, size_groups);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + size_numGroups + 4 + 4 + size_groups, ptr + 8 + 4 + size_numGroups + 4 + 4 + size_groups, checksumSize, 
					"8 + 4 + size_numGroups + 4 + 4 + size_groups::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glGetPerfMonitorGroupsAMD(%p(%u) %d %p(%u) )", stream,(GLint*)(inptr_numGroups.get()), size_numGroups, var_groupsSize, (GLuint*)(inptr_groups.get()), size_groups);
			this->glGetPerfMonitorGroupsAMD((GLint*)(inptr_numGroups.get()), var_groupsSize, (GLuint*)(inptr_groups.get()));
			SET_LASTCALL("glGetPerfMonitorGroupsAMD");
			break;
		}
		case OP_glGetPerfMonitorCountersAMD: {
			GLuint var_group = Unpack<GLuint,uint32_t>(ptr + 8);
			uint32_t size_numCounters  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			InputBuffer inptr_numCounters(ptr + 8 + 4 + 4, size_numCounters);
			uint32_t size_maxActiveCounters  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + size_numCounters);
			InputBuffer inptr_maxActiveCounters(ptr + 8 + 4 + 4 + size_numCounters + 4, size_maxActiveCounters);
			GLsizei var_counterSize = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + size_numCounters + 4 + size_maxActiveCounters);
			uint32_t size_counters  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + size_numCounters + 4 + size_maxActiveCounters + 4);
			InputBuffer inptr_counters(ptr + 8 + 4 + 4 + size_numCounters + 4 + size_maxActiveCounters + 4 + 4, size_counters);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + size_numCounters + 4 + size_maxActiveCounters + 4 + 4 + size_counters, ptr + 8 + 4 + 4 + size_numCounters + 4 + size_maxActiveCounters + 4 + 4 + size_counters, checksumSize, 
					"8 + 4 + 4 + size_numCounters + 4 + size_maxActiveCounters + 4 + 4 + size_counters::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glGetPerfMonitorCountersAMD(%u %p(%u) %p(%u) %d %p(%u) )", stream,var_group, (GLint*)(inptr_numCounters.get()), size_numCounters, (GLint*)(inptr_maxActiveCounters.get()), size_maxActiveCounters, var_counterSize, (GLuint*)(inptr_counters.get()), size_counters);
			this->glGetPerfMonitorCountersAMD(var_group, (GLint*)(inptr_numCounters.get()), (GLint*)(inptr_maxActiveCounters.get()), var_counterSize, (GLuint*)(inptr_counters.get()));
			SET_LASTCALL("glGetPerfMonitorCountersAMD");
			break;
		}
		case OP_glGetPerfMonitorGroupStringAMD: {
			GLuint var_group = Unpack<GLuint,uint32_t>(ptr + 8);
			GLsizei var_bufSize = Unpack<GLsizei,uint32_t>(ptr + 8 + 4);
			uint32_t size_length  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			InputBuffer inptr_length(ptr + 8 + 4 + 4 + 4, size_length);
			uint32_t size_groupString  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + size_length);
			InputBuffer inptr_groupString(ptr + 8 + 4 + 4 + 4 + size_length + 4, size_groupString);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4 + size_length + 4 + size_groupString, ptr + 8 + 4 + 4 + 4 + size_length + 4 + size_groupString, checksumSize, 
					"8 + 4 + 4 + 4 + size_length + 4 + size_groupString::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glGetPerfMonitorGroupStringAMD(%u %d %p(%u) %p(%u) )", stream,var_group, var_bufSize, (GLsizei*)(inptr_length.get()), size_length, (GLchar*)(inptr_groupString.get()), size_groupString);
			this->glGetPerfMonitorGroupStringAMD(var_group, var_bufSize, (GLsizei*)(inptr_length.get()), (GLchar*)(inptr_groupString.get()));
			SET_LASTCALL("glGetPerfMonitorGroupStringAMD");
			break;
		}
		case OP_glGetPerfMonitorCounterStringAMD: {
			GLuint var_group = Unpack<GLuint,uint32_t>(ptr + 8);
			GLuint var_counter = Unpack<GLuint,uint32_t>(ptr + 8 + 4);
			GLsizei var_bufSize = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4);
			uint32_t size_length  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4);
			InputBuffer inptr_length(ptr + 8 + 4 + 4 + 4 + 4, size_length);
			uint32_t size_counterString  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + size_length);
			InputBuffer inptr_counterString(ptr + 8 + 4 + 4 + 4 + 4 + size_length + 4, size_counterString);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4 + 4 + size_length + 4 + size_counterString, ptr + 8 + 4 + 4 + 4 + 4 + size_length + 4 + size_counterString, checksumSize, 
					"8 + 4 + 4 + 4 + 4 + size_length + 4 + size_counterString::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glGetPerfMonitorCounterStringAMD(%u %u %d %p(%u) %p(%u) )", stream,var_group, var_counter, var_bufSize, (GLsizei*)(inptr_length.get()), size_length, (GLchar*)(inptr_counterString.get()), size_counterString);
			this->glGetPerfMonitorCounterStringAMD(var_group, var_counter, var_bufSize, (GLsizei*)(inptr_length.get()), (GLchar*)(inptr_counterString.get()));
			SET_LASTCALL("glGetPerfMonitorCounterStringAMD");
			break;
		}
		case OP_glGetPerfMonitorCounterInfoAMD: {
			GLuint var_group = Unpack<GLuint,uint32_t>(ptr + 8);
			GLuint var_counter = Unpack<GLuint,uint32_t>(ptr + 8 + 4);
			GLenum var_pname = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4);
			uint32_t size_data  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4);
			InputBuffer inptr_data(ptr + 8 + 4 + 4 + 4 + 4, size_data);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4 + 4 + size_data, ptr + 8 + 4 + 4 + 4 + 4 + size_data, checksumSize, 
					"8 + 4 + 4 + 4 + 4 + size_data::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glGetPerfMonitorCounterInfoAMD(%u %u 0x%08x %p(%u) )", stream,var_group, var_counter, var_pname, (GLvoid*)(inptr_data.get()), size_data);
			this->glGetPerfMonitorCounterInfoAMD(var_group, var_counter, var_pname, (GLvoid*)(inptr_data.get()));
			SET_LASTCALL("glGetPerfMonitorCounterInfoAMD");
			break;
		}
		case OP_glGenPerfMonitorsAMD: {
			GLsizei var_n = Unpack<GLsizei,uint32_t>(ptr + 8);
			uint32_t size_monitors  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			InputBuffer inptr_monitors(ptr + 8 + 4 + 4, size_monitors);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + size_monitors, ptr + 8 + 4 + 4 + size_monitors, checksumSize, 
					"8 + 4 + 4 + size_monitors::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glGenPerfMonitorsAMD(%d %p(%u) )", stream,var_n, (GLuint*)(inptr_monitors.get()), size_monitors);
			this->glGenPerfMonitorsAMD(var_n, (GLuint*)(inptr_monitors.get()));
			SET_LASTCALL("glGenPerfMonitorsAMD");
			break;
		}
		case OP_glDeletePerfMonitorsAMD: {
			GLsizei var_n = Unpack<GLsizei,uint32_t>(ptr + 8);
			uint32_t size_monitors  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			InputBuffer inptr_monitors(ptr + 8 + 4 + 4, size_monitors);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + size_monitors, ptr + 8 + 4 + 4 + size_monitors, checksumSize, 
					"8 + 4 + 4 + size_monitors::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glDeletePerfMonitorsAMD(%d %p(%u) )", stream,var_n, (GLuint*)(inptr_monitors.get()), size_monitors);
			this->glDeletePerfMonitorsAMD(var_n, (GLuint*)(inptr_monitors.get()));
			SET_LASTCALL("glDeletePerfMonitorsAMD");
			break;
		}
		case OP_glSelectPerfMonitorCountersAMD: {
			GLuint var_monitor = Unpack<GLuint,uint32_t>(ptr + 8);
			GLboolean var_enable = Unpack<GLboolean,uint8_t>(ptr + 8 + 4);
			GLuint var_group = Unpack<GLuint,uint32_t>(ptr + 8 + 4 + 1);
			GLint var_numCounters = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 1 + 4);
			uint32_t size_countersList  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 1 + 4 + 4);
			InputBuffer inptr_countersList(ptr + 8 + 4 + 1 + 4 + 4 + 4, size_countersList);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 1 + 4 + 4 + 4 + size_countersList, ptr + 8 + 4 + 1 + 4 + 4 + 4 + size_countersList, checksumSize, 
					"8 + 4 + 1 + 4 + 4 + 4 + size_countersList::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glSelectPerfMonitorCountersAMD(%u %d %u %d %p(%u) )", stream,var_monitor, var_enable, var_group, var_numCounters, (GLuint*)(inptr_countersList.get()), size_countersList);
			this->glSelectPerfMonitorCountersAMD(var_monitor, var_enable, var_group, var_numCounters, (GLuint*)(inptr_countersList.get()));
			SET_LASTCALL("glSelectPerfMonitorCountersAMD");
			break;
		}
		case OP_glBeginPerfMonitorAMD: {
			GLuint var_monitor = Unpack<GLuint,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"8 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glBeginPerfMonitorAMD(%u )", stream,var_monitor);
			this->glBeginPerfMonitorAMD(var_monitor);
			SET_LASTCALL("glBeginPerfMonitorAMD");
			break;
		}
		case OP_glEndPerfMonitorAMD: {
			GLuint var_monitor = Unpack<GLuint,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"8 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glEndPerfMonitorAMD(%u )", stream,var_monitor);
			this->glEndPerfMonitorAMD(var_monitor);
			SET_LASTCALL("glEndPerfMonitorAMD");
			break;
		}
		case OP_glGetPerfMonitorCounterDataAMD: {
			GLuint var_monitor = Unpack<GLuint,uint32_t>(ptr + 8);
			GLenum var_pname = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			GLsizei var_dataSize = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4);
			uint32_t size_data  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4);
			InputBuffer inptr_data(ptr + 8 + 4 + 4 + 4 + 4, size_data);
			uint32_t size_bytesWritten  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + size_data);
			InputBuffer inptr_bytesWritten(ptr + 8 + 4 + 4 + 4 + 4 + size_data + 4, size_bytesWritten);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4 + 4 + size_data + 4 + size_bytesWritten, ptr + 8 + 4 + 4 + 4 + 4 + size_data + 4 + size_bytesWritten, checksumSize, 
					"8 + 4 + 4 + 4 + 4 + size_data + 4 + size_bytesWritten::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glGetPerfMonitorCounterDataAMD(%u 0x%08x %d %p(%u) %p(%u) )", stream,var_monitor, var_pname, var_dataSize, (GLuint*)(inptr_data.get()), size_data, (GLint*)(inptr_bytesWritten.get()), size_bytesWritten);
			this->glGetPerfMonitorCounterDataAMD(var_monitor, var_pname, var_dataSize, (GLuint*)(inptr_data.get()), (GLint*)(inptr_bytesWritten.get()));
			SET_LASTCALL("glGetPerfMonitorCounterDataAMD");
			break;
		}
		case OP_glRenderbufferStorageMultisampleIMG: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLsizei var_samples = Unpack<GLsizei,uint32_t>(ptr + 8 + 4);
			GLenum var_internalformat = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4);
			GLsizei var_width = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4);
			GLsizei var_height = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4 + 4, checksumSize, 
					"8 + 4 + 4 + 4 + 4 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glRenderbufferStorageMultisampleIMG(0x%08x %d 0x%08x %d %d )", stream,var_target, var_samples, var_internalformat, var_width, var_height);
			this->glRenderbufferStorageMultisampleIMG(var_target, var_samples, var_internalformat, var_width, var_height);
			SET_LASTCALL("glRenderbufferStorageMultisampleIMG");
			break;
		}
		case OP_glFramebufferTexture2DMultisampleIMG: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLenum var_attachment = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			GLenum var_textarget = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4);
			GLuint var_texture = Unpack<GLuint,uint32_t>(ptr + 8 + 4 + 4 + 4);
			GLint var_level = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			GLsizei var_samples = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4, checksumSize, 
					"8 + 4 + 4 + 4 + 4 + 4 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glFramebufferTexture2DMultisampleIMG(0x%08x 0x%08x 0x%08x %u %d %d )", stream,var_target, var_attachment, var_textarget, var_texture, var_level, var_samples);
			this->glFramebufferTexture2DMultisampleIMG(var_target, var_attachment, var_textarget, var_texture, var_level, var_samples);
			SET_LASTCALL("glFramebufferTexture2DMultisampleIMG");
			break;
		}
		case OP_glDeleteFencesNV: {
			GLsizei var_n = Unpack<GLsizei,uint32_t>(ptr + 8);
			uint32_t size_fences  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			InputBuffer inptr_fences(ptr + 8 + 4 + 4, size_fences);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + size_fences, ptr + 8 + 4 + 4 + size_fences, checksumSize, 
					"8 + 4 + 4 + size_fences::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glDeleteFencesNV(%d %p(%u) )", stream,var_n, (const GLuint*)(inptr_fences.get()), size_fences);
			this->glDeleteFencesNV(var_n, (const GLuint*)(inptr_fences.get()));
			SET_LASTCALL("glDeleteFencesNV");
			break;
		}
		case OP_glGenFencesNV: {
			GLsizei var_n = Unpack<GLsizei,uint32_t>(ptr + 8);
			uint32_t size_fences  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			InputBuffer inptr_fences(ptr + 8 + 4 + 4, size_fences);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + size_fences, ptr + 8 + 4 + 4 + size_fences, checksumSize, 
					"8 + 4 + 4 + size_fences::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glGenFencesNV(%d %p(%u) )", stream,var_n, (GLuint*)(inptr_fences.get()), size_fences);
			this->glGenFencesNV(var_n, (GLuint*)(inptr_fences.get()));
			SET_LASTCALL("glGenFencesNV");
			break;
		}
		case OP_glIsFenceNV: {
			GLuint var_fence = Unpack<GLuint,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"8 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(GLboolean);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			DEBUG("gles2(%p): glIsFenceNV(%u )", stream,var_fence);
			*(GLboolean *)(&tmpBuf[0]) = 			this->glIsFenceNV(var_fence);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(&tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glIsFenceNV");
			break;
		}
		case OP_glTestFenceNV: {
			GLuint var_fence = Unpack<GLuint,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"8 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(GLboolean);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			DEBUG("gles2(%p): glTestFenceNV(%u )", stream,var_fence);
			*(GLboolean *)(&tmpBuf[0]) = 			this->glTestFenceNV(var_fence);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(&tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glTestFenceNV");
			break;
		}
		case OP_glGetFenceivNV: {
			GLuint var_fence = Unpack<GLuint,uint32_t>(ptr + 8);
			GLenum var_pname = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			uint32_t size_params  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			InputBuffer inptr_params(ptr + 8 + 4 + 4 + 4, size_params);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4 + size_params, ptr + 8 + 4 + 4 + 4 + size_params, checksumSize, 
					"8 + 4 + 4 + 4 + size_params::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glGetFenceivNV(%u 0x%08x %p(%u) )", stream,var_fence, var_pname, (GLint*)(inptr_params.get()), size_params);
			this->glGetFenceivNV(var_fence, var_pname, (GLint*)(inptr_params.get()));
			SET_LASTCALL("glGetFenceivNV");
			break;
		}
		case OP_glFinishFenceNV: {
			GLuint var_fence = Unpack<GLuint,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"8 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glFinishFenceNV(%u )", stream,var_fence);
			this->glFinishFenceNV(var_fence);
			SET_LASTCALL("glFinishFenceNV");
			break;
		}
		case OP_glSetFenceNV: {
			GLuint var_fence = Unpack<GLuint,uint32_t>(ptr + 8);
			GLenum var_condition = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize, 
					"8 + 4 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glSetFenceNV(%u 0x%08x )", stream,var_fence, var_condition);
			this->glSetFenceNV(var_fence, var_condition);
			SET_LASTCALL("glSetFenceNV");
			break;
		}
		case OP_glCoverageMaskNV: {
			GLboolean var_mask = Unpack<GLboolean,uint8_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 1, ptr + 8 + 1, checksumSize, 
					"8 + 1::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glCoverageMaskNV(%d )", stream,var_mask);
			this->glCoverageMaskNV(var_mask);
			SET_LASTCALL("glCoverageMaskNV");
			break;
		}
		case OP_glCoverageOperationNV: {
			GLenum var_operation = Unpack<GLenum,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"8 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glCoverageOperationNV(0x%08x )", stream,var_operation);
			this->glCoverageOperationNV(var_operation);
			SET_LASTCALL("glCoverageOperationNV");
			break;
		}
		case OP_glGetDriverControlsQCOM: {
			uint32_t size_num  = Unpack<uint32_t,uint32_t>(ptr + 8);
			InputBuffer inptr_num(ptr + 8 + 4, size_num);
			GLsizei var_size = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + size_num);
			uint32_t size_driverControls  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + size_num + 4);
			InputBuffer inptr_driverControls(ptr + 8 + 4 + size_num + 4 + 4, size_driverControls);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + size_num + 4 + 4 + size_driverControls, ptr + 8 + 4 + size_num + 4 + 4 + size_driverControls, checksumSize, 
					"8 + 4 + size_num + 4 + 4 + size_driverControls::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glGetDriverControlsQCOM(%p(%u) %d %p(%u) )", stream,(GLint*)(inptr_num.get()), size_num, var_size, (GLuint*)(inptr_driverControls.get()), size_driverControls);
			this->glGetDriverControlsQCOM((GLint*)(inptr_num.get()), var_size, (GLuint*)(inptr_driverControls.get()));
			SET_LASTCALL("glGetDriverControlsQCOM");
			break;
		}
		case OP_glGetDriverControlStringQCOM: {
			GLuint var_driverControl = Unpack<GLuint,uint32_t>(ptr + 8);
			GLsizei var_bufSize = Unpack<GLsizei,uint32_t>(ptr + 8 + 4);
			uint32_t size_length  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			InputBuffer inptr_length(ptr + 8 + 4 + 4 + 4, size_length);
			uint32_t size_driverControlString  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + size_length);
			InputBuffer inptr_driverControlString(ptr + 8 + 4 + 4 + 4 + size_length + 4, size_driverControlString);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4 + size_length + 4 + size_driverControlString, ptr + 8 + 4 + 4 + 4 + size_length + 4 + size_driverControlString, checksumSize, 
					"8 + 4 + 4 + 4 + size_length + 4 + size_driverControlString::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glGetDriverControlStringQCOM(%u %d %p(%u) %p(%u) )", stream,var_driverControl, var_bufSize, (GLsizei*)(inptr_length.get()), size_length, (GLchar*)(inptr_driverControlString.get()), size_driverControlString);
			this->glGetDriverControlStringQCOM(var_driverControl, var_bufSize, (GLsizei*)(inptr_length.get()), (GLchar*)(inptr_driverControlString.get()));
			SET_LASTCALL("glGetDriverControlStringQCOM");
			break;
		}
		case OP_glEnableDriverControlQCOM: {
			GLuint var_driverControl = Unpack<GLuint,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"8 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glEnableDriverControlQCOM(%u )", stream,var_driverControl);
			this->glEnableDriverControlQCOM(var_driverControl);
			SET_LASTCALL("glEnableDriverControlQCOM");
			break;
		}
		case OP_glDisableDriverControlQCOM: {
			GLuint var_driverControl = Unpack<GLuint,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"8 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glDisableDriverControlQCOM(%u )", stream,var_driverControl);
			this->glDisableDriverControlQCOM(var_driverControl);
			SET_LASTCALL("glDisableDriverControlQCOM");
			break;
		}
		case OP_glExtGetTexturesQCOM: {
			uint32_t size_textures  = Unpack<uint32_t,uint32_t>(ptr + 8);
			InputBuffer inptr_textures(ptr + 8 + 4, size_textures);
			GLint var_maxTextures = Unpack<GLint,uint32_t>(ptr + 8 + 4 + size_textures);
			uint32_t size_numTextures  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + size_textures + 4);
			InputBuffer inptr_numTextures(ptr + 8 + 4 + size_textures + 4 + 4, size_numTextures);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + size_textures + 4 + 4 + size_numTextures, ptr + 8 + 4 + size_textures + 4 + 4 + size_numTextures, checksumSize, 
					"8 + 4 + size_textures + 4 + 4 + size_numTextures::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glExtGetTexturesQCOM(%p(%u) %d %p(%u) )", stream,(GLuint*)(inptr_textures.get()), size_textures, var_maxTextures, (GLint*)(inptr_numTextures.get()), size_numTextures);
			this->glExtGetTexturesQCOM((GLuint*)(inptr_textures.get()), var_maxTextures, (GLint*)(inptr_numTextures.get()));
			SET_LASTCALL("glExtGetTexturesQCOM");
			break;
		}
		case OP_glExtGetBuffersQCOM: {
			uint32_t size_buffers  = Unpack<uint32_t,uint32_t>(ptr + 8);
			InputBuffer inptr_buffers(ptr + 8 + 4, size_buffers);
			GLint var_maxBuffers = Unpack<GLint,uint32_t>(ptr + 8 + 4 + size_buffers);
			uint32_t size_numBuffers  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + size_buffers + 4);
			InputBuffer inptr_numBuffers(ptr + 8 + 4 + size_buffers + 4 + 4, size_numBuffers);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + size_buffers + 4 + 4 + size_numBuffers, ptr + 8 + 4 + size_buffers + 4 + 4 + size_numBuffers, checksumSize, 
					"8 + 4 + size_buffers + 4 + 4 + size_numBuffers::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glExtGetBuffersQCOM(%p(%u) %d %p(%u) )", stream,(GLuint*)(inptr_buffers.get()), size_buffers, var_maxBuffers, (GLint*)(inptr_numBuffers.get()), size_numBuffers);
			this->glExtGetBuffersQCOM((GLuint*)(inptr_buffers.get()), var_maxBuffers, (GLint*)(inptr_numBuffers.get()));
			SET_LASTCALL("glExtGetBuffersQCOM");
			break;
		}
		case OP_glExtGetRenderbuffersQCOM: {
			uint32_t size_renderbuffers  = Unpack<uint32_t,uint32_t>(ptr + 8);
			InputBuffer inptr_renderbuffers(ptr + 8 + 4, size_renderbuffers);
			GLint var_maxRenderbuffers = Unpack<GLint,uint32_t>(ptr + 8 + 4 + size_renderbuffers);
			uint32_t size_numRenderbuffers  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + size_renderbuffers + 4);
			InputBuffer inptr_numRenderbuffers(ptr + 8 + 4 + size_renderbuffers + 4 + 4, size_numRenderbuffers);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + size_renderbuffers + 4 + 4 + size_numRenderbuffers, ptr + 8 + 4 + size_renderbuffers + 4 + 4 + size_numRenderbuffers, checksumSize, 
					"8 + 4 + size_renderbuffers + 4 + 4 + size_numRenderbuffers::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glExtGetRenderbuffersQCOM(%p(%u) %d %p(%u) )", stream,(GLuint*)(inptr_renderbuffers.get()), size_renderbuffers, var_maxRenderbuffers, (GLint*)(inptr_numRenderbuffers.get()), size_numRenderbuffers);
			this->glExtGetRenderbuffersQCOM((GLuint*)(inptr_renderbuffers.get()), var_maxRenderbuffers, (GLint*)(inptr_numRenderbuffers.get()));
			SET_LASTCALL("glExtGetRenderbuffersQCOM");
			break;
		}
		case OP_glExtGetFramebuffersQCOM: {
			uint32_t size_framebuffers  = Unpack<uint32_t,uint32_t>(ptr + 8);
			InputBuffer inptr_framebuffers(ptr + 8 + 4, size_framebuffers);
			GLint var_maxFramebuffers = Unpack<GLint,uint32_t>(ptr + 8 + 4 + size_framebuffers);
			uint32_t size_numFramebuffers  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + size_framebuffers + 4);
			InputBuffer inptr_numFramebuffers(ptr + 8 + 4 + size_framebuffers + 4 + 4, size_numFramebuffers);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + size_framebuffers + 4 + 4 + size_numFramebuffers, ptr + 8 + 4 + size_framebuffers + 4 + 4 + size_numFramebuffers, checksumSize, 
					"8 + 4 + size_framebuffers + 4 + 4 + size_numFramebuffers::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glExtGetFramebuffersQCOM(%p(%u) %d %p(%u) )", stream,(GLuint*)(inptr_framebuffers.get()), size_framebuffers, var_maxFramebuffers, (GLint*)(inptr_numFramebuffers.get()), size_numFramebuffers);
			this->glExtGetFramebuffersQCOM((GLuint*)(inptr_framebuffers.get()), var_maxFramebuffers, (GLint*)(inptr_numFramebuffers.get()));
			SET_LASTCALL("glExtGetFramebuffersQCOM");
			break;
		}
		case OP_glExtGetTexLevelParameterivQCOM: {
			GLuint var_texture = Unpack<GLuint,uint32_t>(ptr + 8);
			GLenum var_face = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			GLint var_level = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4);
			GLenum var_pname = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4 + 4);
			uint32_t size_params  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			InputBuffer inptr_params(ptr + 8 + 4 + 4 + 4 + 4 + 4, size_params);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4 + 4 + 4 + size_params, ptr + 8 + 4 + 4 + 4 + 4 + 4 + size_params, checksumSize, 
					"8 + 4 + 4 + 4 + 4 + 4 + size_params::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glExtGetTexLevelParameterivQCOM(%u 0x%08x %d 0x%08x %p(%u) )", stream,var_texture, var_face, var_level, var_pname, (GLint*)(inptr_params.get()), size_params);
			this->glExtGetTexLevelParameterivQCOM(var_texture, var_face, var_level, var_pname, (GLint*)(inptr_params.get()));
			SET_LASTCALL("glExtGetTexLevelParameterivQCOM");
			break;
		}
		case OP_glExtTexObjectStateOverrideiQCOM: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLenum var_pname = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			GLint var_param = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4, checksumSize, 
					"8 + 4 + 4 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glExtTexObjectStateOverrideiQCOM(0x%08x 0x%08x %d )", stream,var_target, var_pname, var_param);
			this->glExtTexObjectStateOverrideiQCOM(var_target, var_pname, var_param);
			SET_LASTCALL("glExtTexObjectStateOverrideiQCOM");
			break;
		}
		case OP_glExtGetTexSubImageQCOM: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			GLint var_level = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLint var_xoffset = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4);
			GLint var_yoffset = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4);
			GLint var_zoffset = Unpack<GLint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			GLsizei var_width = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4);
			GLsizei var_height = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4);
			GLsizei var_depth = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			GLenum var_format = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			GLenum var_type = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			uint32_t size_texels  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4);
			InputBuffer inptr_texels(ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4, size_texels);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + size_texels, ptr + 8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + size_texels, checksumSize, 
					"8 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + 4 + size_texels::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glExtGetTexSubImageQCOM(0x%08x %d %d %d %d %d %d %d 0x%08x 0x%08x %p(%u) )", stream,var_target, var_level, var_xoffset, var_yoffset, var_zoffset, var_width, var_height, var_depth, var_format, var_type, (GLvoid*)(inptr_texels.get()), size_texels);
			this->glExtGetTexSubImageQCOM(var_target, var_level, var_xoffset, var_yoffset, var_zoffset, var_width, var_height, var_depth, var_format, var_type, (GLvoid*)(inptr_texels.get()));
			SET_LASTCALL("glExtGetTexSubImageQCOM");
			break;
		}
		case OP_glExtGetBufferPointervQCOM: {
			GLenum var_target = Unpack<GLenum,uint32_t>(ptr + 8);
			uint32_t size_params  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			InputBuffer inptr_params(ptr + 8 + 4 + 4, size_params);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + size_params, ptr + 8 + 4 + 4 + size_params, checksumSize, 
					"8 + 4 + 4 + size_params::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glExtGetBufferPointervQCOM(0x%08x %p(%u) )", stream,var_target, (GLvoidptr*)(inptr_params.get()), size_params);
			this->glExtGetBufferPointervQCOM(var_target, (GLvoidptr*)(inptr_params.get()));
			SET_LASTCALL("glExtGetBufferPointervQCOM");
			break;
		}
		case OP_glExtGetShadersQCOM: {
			uint32_t size_shaders  = Unpack<uint32_t,uint32_t>(ptr + 8);
			InputBuffer inptr_shaders(ptr + 8 + 4, size_shaders);
			GLint var_maxShaders = Unpack<GLint,uint32_t>(ptr + 8 + 4 + size_shaders);
			uint32_t size_numShaders  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + size_shaders + 4);
			InputBuffer inptr_numShaders(ptr + 8 + 4 + size_shaders + 4 + 4, size_numShaders);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + size_shaders + 4 + 4 + size_numShaders, ptr + 8 + 4 + size_shaders + 4 + 4 + size_numShaders, checksumSize, 
					"8 + 4 + size_shaders + 4 + 4 + size_numShaders::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glExtGetShadersQCOM(%p(%u) %d %p(%u) )", stream,(GLuint*)(inptr_shaders.get()), size_shaders, var_maxShaders, (GLint*)(inptr_numShaders.get()), size_numShaders);
			this->glExtGetShadersQCOM((GLuint*)(inptr_shaders.get()), var_maxShaders, (GLint*)(inptr_numShaders.get()));
			SET_LASTCALL("glExtGetShadersQCOM");
			break;
		}
		case OP_glExtGetProgramsQCOM: {
			uint32_t size_programs  = Unpack<uint32_t,uint32_t>(ptr + 8);
			InputBuffer inptr_programs(ptr + 8 + 4, size_programs);
			GLint var_maxPrograms = Unpack<GLint,uint32_t>(ptr + 8 + 4 + size_programs);
			uint32_t size_numPrograms  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + size_programs + 4);
			InputBuffer inptr_numPrograms(ptr + 8 + 4 + size_programs + 4 + 4, size_numPrograms);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + size_programs + 4 + 4 + size_numPrograms, ptr + 8 + 4 + size_programs + 4 + 4 + size_numPrograms, checksumSize, 
					"8 + 4 + size_programs + 4 + 4 + size_numPrograms::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glExtGetProgramsQCOM(%p(%u) %d %p(%u) )", stream,(GLuint*)(inptr_programs.get()), size_programs, var_maxPrograms, (GLint*)(inptr_numPrograms.get()), size_numPrograms);
			this->glExtGetProgramsQCOM((GLuint*)(inptr_programs.get()), var_maxPrograms, (GLint*)(inptr_numPrograms.get()));
			SET_LASTCALL("glExtGetProgramsQCOM");
			break;
		}
		case OP_glExtIsProgramBinaryQCOM: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"8 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(GLboolean);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			DEBUG("gles2(%p): glExtIsProgramBinaryQCOM(%u )", stream,var_program);
			*(GLboolean *)(&tmpBuf[0]) = 			this->glExtIsProgramBinaryQCOM(var_program);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(&tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glExtIsProgramBinaryQCOM");
			break;
		}
		case OP_glExtGetProgramBinarySourceQCOM: {
			GLuint var_program = Unpack<GLuint,uint32_t>(ptr + 8);
			GLenum var_shadertype = Unpack<GLenum,uint32_t>(ptr + 8 + 4);
			uint32_t size_source  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4);
			InputBuffer inptr_source(ptr + 8 + 4 + 4 + 4, size_source);
			uint32_t size_length  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + size_source);
			InputBuffer inptr_length(ptr + 8 + 4 + 4 + 4 + size_source + 4, size_length);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4 + size_source + 4 + size_length, ptr + 8 + 4 + 4 + 4 + size_source + 4 + size_length, checksumSize, 
					"8 + 4 + 4 + 4 + size_source + 4 + size_length::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glExtGetProgramBinarySourceQCOM(%u 0x%08x %p(%u) %p(%u) )", stream,var_program, var_shadertype, (GLchar*)(inptr_source.get()), size_source, (GLint*)(inptr_length.get()), size_length);
			this->glExtGetProgramBinarySourceQCOM(var_program, var_shadertype, (GLchar*)(inptr_source.get()), (GLint*)(inptr_length.get()));
			SET_LASTCALL("glExtGetProgramBinarySourceQCOM");
			break;
		}
		case OP_glStartTilingQCOM: {
			GLuint var_x = Unpack<GLuint,uint32_t>(ptr + 8);
			GLuint var_y = Unpack<GLuint,uint32_t>(ptr + 8 + 4);
			GLuint var_width = Unpack<GLuint,uint32_t>(ptr + 8 + 4 + 4);
			GLuint var_height = Unpack<GLuint,uint32_t>(ptr + 8 + 4 + 4 + 4);
			GLbitfield var_preserveMask = Unpack<GLbitfield,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4 + 4, checksumSize, 
					"8 + 4 + 4 + 4 + 4 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glStartTilingQCOM(%u %u %u %u 0x%08x )", stream,var_x, var_y, var_width, var_height, var_preserveMask);
			this->glStartTilingQCOM(var_x, var_y, var_width, var_height, var_preserveMask);
			SET_LASTCALL("glStartTilingQCOM");
			break;
		}
		case OP_glEndTilingQCOM: {
			GLbitfield var_preserveMask = Unpack<GLbitfield,uint32_t>(ptr + 8);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4, ptr + 8 + 4, checksumSize, 
					"8 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glEndTilingQCOM(0x%08x )", stream,var_preserveMask);
			this->glEndTilingQCOM(var_preserveMask);
			SET_LASTCALL("glEndTilingQCOM");
			break;
		}
		case OP_glVertexAttribPointerData: {
			GLuint var_indx = Unpack<GLuint,uint32_t>(ptr + 8);
			GLint var_size = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLenum var_type = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4);
			GLboolean var_normalized = Unpack<GLboolean,uint8_t>(ptr + 8 + 4 + 4 + 4);
			GLsizei var_stride = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 1);
			uint32_t size_data  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4 + 1 + 4);
			InputBuffer inptr_data(ptr + 8 + 4 + 4 + 4 + 1 + 4 + 4, size_data);
			GLuint var_datalen = Unpack<GLuint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 1 + 4 + 4 + size_data);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4 + 1 + 4 + 4 + size_data + 4, ptr + 8 + 4 + 4 + 4 + 1 + 4 + 4 + size_data + 4, checksumSize, 
					"8 + 4 + 4 + 4 + 1 + 4 + 4 + size_data + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glVertexAttribPointerData(%u %d 0x%08x %d %d %p(%u) %u )", stream,var_indx, var_size, var_type, var_normalized, var_stride, (void*)(inptr_data.get()), size_data, var_datalen);
			this->glVertexAttribPointerData(this, var_indx, var_size, var_type, var_normalized, var_stride, (void*)(inptr_data.get()), var_datalen);
			SET_LASTCALL("glVertexAttribPointerData");
			break;
		}
		case OP_glVertexAttribPointerOffset: {
			GLuint var_indx = Unpack<GLuint,uint32_t>(ptr + 8);
			GLint var_size = Unpack<GLint,uint32_t>(ptr + 8 + 4);
			GLenum var_type = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4);
			GLboolean var_normalized = Unpack<GLboolean,uint8_t>(ptr + 8 + 4 + 4 + 4);
			GLsizei var_stride = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + 4 + 1);
			GLuint var_offset = Unpack<GLuint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 1 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4 + 1 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 1 + 4 + 4, checksumSize, 
					"8 + 4 + 4 + 4 + 1 + 4 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glVertexAttribPointerOffset(%u %d 0x%08x %d %d %u )", stream,var_indx, var_size, var_type, var_normalized, var_stride, var_offset);
			this->glVertexAttribPointerOffset(this, var_indx, var_size, var_type, var_normalized, var_stride, var_offset);
			SET_LASTCALL("glVertexAttribPointerOffset");
			break;
		}
		case OP_glDrawElementsOffset: {
			GLenum var_mode = Unpack<GLenum,uint32_t>(ptr + 8);
			GLsizei var_count = Unpack<GLsizei,uint32_t>(ptr + 8 + 4);
			GLenum var_type = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4);
			GLuint var_offset = Unpack<GLuint,uint32_t>(ptr + 8 + 4 + 4 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4 + 4, ptr + 8 + 4 + 4 + 4 + 4, checksumSize, 
					"8 + 4 + 4 + 4 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glDrawElementsOffset(0x%08x %d 0x%08x %u )", stream,var_mode, var_count, var_type, var_offset);
			this->glDrawElementsOffset(this, var_mode, var_count, var_type, var_offset);
			SET_LASTCALL("glDrawElementsOffset");
			break;
		}
		case OP_glDrawElementsData: {
			GLenum var_mode = Unpack<GLenum,uint32_t>(ptr + 8);
			GLsizei var_count = Unpack<GLsizei,uint32_t>(ptr + 8 + 4);
			GLenum var_type = Unpack<GLenum,uint32_t>(ptr + 8 + 4 + 4);
			uint32_t size_data  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4 + 4 + 4);
			InputBuffer inptr_data(ptr + 8 + 4 + 4 + 4 + 4, size_data);
			GLuint var_datalen = Unpack<GLuint,uint32_t>(ptr + 8 + 4 + 4 + 4 + 4 + size_data);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + 4 + 4 + size_data + 4, ptr + 8 + 4 + 4 + 4 + 4 + size_data + 4, checksumSize, 
					"8 + 4 + 4 + 4 + 4 + size_data + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glDrawElementsData(0x%08x %d 0x%08x %p(%u) %u )", stream,var_mode, var_count, var_type, (void*)(inptr_data.get()), size_data, var_datalen);
			this->glDrawElementsData(this, var_mode, var_count, var_type, (void*)(inptr_data.get()), var_datalen);
			SET_LASTCALL("glDrawElementsData");
			break;
		}
		case OP_glGetCompressedTextureFormats: {
			int var_count = Unpack<int,uint32_t>(ptr + 8);
			uint32_t size_formats  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4, ptr + 8 + 4 + 4, checksumSize, 
					"8 + 4 + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = size_formats;
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			OutputBuffer outptr_formats(&tmpBuf[0], size_formats);
			DEBUG("gles2(%p): glGetCompressedTextureFormats(%d %p(%u) )", stream,var_count, (GLint*)(outptr_formats.get()), size_formats);
			this->glGetCompressedTextureFormats(this, var_count, (GLint*)(outptr_formats.get()));
			outptr_formats.flush();
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(&tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glGetCompressedTextureFormats");
			break;
		}
		case OP_glShaderString: {
			GLuint var_shader = Unpack<GLuint,uint32_t>(ptr + 8);
			uint32_t size_string  = Unpack<uint32_t,uint32_t>(ptr + 8 + 4);
			InputBuffer inptr_string(ptr + 8 + 4 + 4, size_string);
			GLsizei var_len = Unpack<GLsizei,uint32_t>(ptr + 8 + 4 + 4 + size_string);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8 + 4 + 4 + size_string + 4, ptr + 8 + 4 + 4 + size_string + 4, checksumSize, 
					"8 + 4 + 4 + size_string + 4::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			DEBUG("gles2(%p): glShaderString(%u %p(%u) %d )", stream,var_shader, (const GLchar*)(inptr_string.get()), size_string, var_len);
			this->glShaderString(this, var_shader, (const GLchar*)(inptr_string.get()), var_len);
			SET_LASTCALL("glShaderString");
			break;
		}
		case OP_glFinishRoundTrip: {
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::validOrDie(ptr, 8, ptr + 8, checksumSize, 
					"8::decode, OP_gles2_decoder_context_t: GL checksumCalculator failure\n");
			}
			size_t totalTmpSize = sizeof(int);
			totalTmpSize += checksumSize;
			unsigned char *tmpBuf = stream->alloc(totalTmpSize);
			DEBUG("gles2(%p): glFinishRoundTrip()", stream);
			*(int *)(&tmpBuf[0]) = 			this->glFinishRoundTrip(this);
			if (useChecksum) {
				ChecksumCalculatorThreadInfo::writeChecksum(&tmpBuf[0], totalTmpSize - checksumSize, &tmpBuf[totalTmpSize - checksumSize], checksumSize);
			}
			stream->flush();
			SET_LASTCALL("glFinishRoundTrip");
			break;
		}
			default:
				unknownOpcode = true;
		} //switch
#ifdef CHECK_GL_ERROR
	int err = lastCall[0] ? this->glGetError() : GL_NO_ERROR;
	if (err) fprintf(stderr, "gles2 Error: 0x%X in %s\n", err, lastCall);
#endif
		if (!unknownOpcode) {
			pos += packetLen;
			ptr += packetLen;
		}
	} // while
	return pos;
}
